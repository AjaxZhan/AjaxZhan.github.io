<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java基础篇--Collection接口(1)</title>
      <link href="/2023/01/16/230116JavaBasic5/"/>
      <url>/2023/01/16/230116JavaBasic5/</url>
      
        <content type="html"><![CDATA[<div class="tip info"><p>前方高能，将涉及较多的底层源码和数据结构与算法</p></div><h1 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h1><ol><li>集合框架体系</li><li>Collection接口之List接口</li><li>Collection接口之Set接口</li><li>Map接口(下一篇博客)</li><li>Collections工具类(下一篇博客)</li></ol><h1 id="集合框架体系图"><a href="#集合框架体系图" class="headerlink" title="集合框架体系图"></a>集合框架体系图</h1><p>集合主要分为 <span class='p red'>单列集合</span>以及<span class='p red'>双列集合（KV）</span></p><p>Collection接口有两个重要的子接口：List接口和Set接口。其实现子类均为单列集合。<br>List下设：ArrayList、Vector、LinkedList<br>Set下设：HashSet、TreeSet<br>Map下设：HashMap(LinkedHashMap)、Hastable(Properties)、TreeMap</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://s2.loli.net/2023/01/18/tj8HwSFlG2yXERe.png" alt="集合框架体系图"/></div><span class="image-caption">集合框架体系图</span></div><h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><h2 id="Collection接口介绍"><a href="#Collection接口介绍" class="headerlink" title="Collection接口介绍"></a>Collection接口介绍</h2><ol><li>Collection的实现子类，可以存放多个元素，每个元素可以是Object。</li><li>有些Collection实现类可以存放重复元素，有些不可以。</li><li>存放顺序有序List、存放顺序无序为Set</li><li>没有直接实现子类，通过子接口List、Set实现。</li></ol><h2 id="Collection接口常见方法"><a href="#Collection接口常见方法" class="headerlink" title="Collection接口常见方法"></a>Collection接口常见方法</h2><p class='p red'>这里以ArrayList为例子</p><ul><li>添加：add(Object value)。如果是基本数据类型会自动装箱。</li><li>删除：<ul><li>remove(index)指定索引，返回删除的元素</li><li>remove(Object value)指定元素，返回是否成功</li></ul></li><li>元素是否存在：<span class='p blue'>contains(Object)</span></li><li>个数：size()</li><li>是否为空：isEmpty()</li><li>清空: clear()</li><li>添加多个元素：<span class='p blue'>addAll(Collection)参数是Collection，可以传入ArrayList</span></li><li>查找多个元素:<span class='p blue'>containsAll(Collection)参数是Collection，可以传入ArrayList</span></li><li>删除多个元素：<span class='p blue'>removeAll(Collection)参数是Collection，可以传入ArrayList</span></li></ul><h2 id="Collection-遍历方式"><a href="#Collection-遍历方式" class="headerlink" title="Collection 遍历方式"></a>Collection 遍历方式</h2><h3 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h3><p>Collection实现了父接口Iterable，实现了Collection的集合类都有一个iterator()方法，可以返回Iterator对象对元素遍历。<br>模板一般如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span>  <span class="operator">=</span> coll.iterator(); <span class="comment">// 得到迭代器</span></span><br><span class="line"><span class="keyword">while</span>( iterator.hasNext())&#123; <span class="comment">// **必须先判断有下一个元素，hasNext必须调用**</span></span><br><span class="line">sout(iterator.next()); <span class="comment">// next的作用：往下移动 + 将下移以后的集合位置上的元素返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当程序退出的时候，iterator指向最后一个元素。</span></span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>iterator只可遍历集合，本身不存在对象。</li><li>如果希望再次遍历，需要重置迭代器。iterator = col.interator();</li><li>快捷键：itit 或者Ctrl+J</li></ol><h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><p>简化版的iterator，底层就是iterator，所以只能遍历Collection和数组。<br>快捷键：大写i</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object obj : books)&#123; sout(obj);&#125;</span><br></pre></td></tr></table></figure><h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ol><li>List存放的元素有序，并且可以重复。</li><li>支持索引，从0开始。底层是数组。访问方式：list.get(index);</li><li>JDK API中List接口的实现类很多，不只是这里介绍的三种。</li></ol><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>底层由数组实现，基本等同Vector，但是<span class='p red'>ArrayList线程不安全但是效率高，建议单线程用，而多线程建议用Vector。</span></p><details class="folding-tag" blue><summary> 先说结论 </summary>              <div class='content'>              <ul><li>底层：ArrayList中维护的Object类型的数组elementData。</li><li>扩容机制：<ul><li>无参创建默认数组容量为0，第一次添加扩容成10。如果还需要扩容，每次为原来的1.5倍</li><li>有参构造初始为指定容量，以后按照1.5倍扩容。</li></ul></li></ul>              </div>            </details><details class="folding-tag" red><summary> 再看底层代码 </summary>              <div class='content'>              <p>分析List.add()如何走：</p><ol><li>走ensureCapacityInternal()，确认内部容量，然后再进行数组赋值elementData[size++]<ol><li>如果数组为空，给最小容量Math.max(DEFAULT,minCapacity);//DEFAULT就是10.</li><li>走ensureExplictCapacity()确认是否需要扩容<ol><li>modcount++;（防止多线程操作）</li><li>minCapacity - elementData.length &gt; 0 即数组大小不足，执行grow(minCapacity); 进行扩容</li></ol></li></ol></li><li>问题来了，核心的grow()方法如何扩容？<ol><li>old = 容量；new = old + old&gt;&gt;1; 也就是1.5倍了</li><li>首先是两个特判<ol><li>如果 new - min &lt; 0 这里是 0 - 10（用来处理第一次） new = min; 也就是说第一次扩容，扩容了10。</li><li>如果 new - MAX_ARRAY_SIZE(一个很大的常量) &gt; 0（处理容量太大）执行hugeCapacity方法</li></ol></li><li>最终执行 elementData = Arrays.copyOf(elementData,newCapacity);</li></ol></li></ol>              </div>            </details><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>底层也是Object数组，但是为线程同步。<br>扩容机制：无参默认10，满按2倍扩容。</p><details class="folding-tag" red><summary> Vector底层机制类似ArrayList </summary>              <div class='content'>              <p>分析List.add()如何走：</p><ol><li>modcount++;  执行ensureCapacityHelper();不够就执行grow()</li><li>grow()<ol><li>old = length;</li><li>new = old + ((capacityIncrement &gt; 0)? capacityIncrement : old)默认就是后者，就是两倍。capacityIncrement是为了方便代码的灵活性，自己自定义数组的扩容大小。</li><li>如果new - min &lt;0 执行new = min; 再执行max判断，最后执行copyof(vector,new);</li></ol></li></ol>              </div>            </details><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><ul><li>底层：双向链表 + 双端队列</li><li>可以添加任意元素</li><li>线程不安全！</li><li>与ArrayList相比，增删效率高，改查效率低。实际开发中多是查询业务，所以ArrayList用的多。</li></ul><details class="folding-tag" blue><summary> 先说结论 </summary>              <div class='content'>              <ul><li>底层维护了双向链表。</li><li>维护了两个属性：first、last指向首节点和尾节点。</li><li>每个Node节点维护了next、prev、item三个元素。</li><li>添加删除不是通过数组，所有效率不错。</li></ul>              </div>            </details><details class="folding-tag" red><summary> 再说底层 </summary>              <div class='content'>              <p>分析List.add()如何走：</p><ol><li>调用add()方法会默认执行linklast(e)。</li><li>linklast()内会new一个新节点，加到末尾。</li><li>如果是第一次，这个节点样子为两头为空。</li></ol><p>list.remove()分析：默认头删，除此之外还支持index和值</p><ol><li>remove() 进去直接调用 removeFirst()</li><li>removeFirst()内，如果空抛出异常，否则调用unlinkFirst()</li><li>unlinkFirst(f) 就是删除链表。<ol><li>取出元素方便返回。</li><li>next指向f的next</li><li>f的item为 null，next变null(help gc) first为next，next的prev为null</li></ol></li></ol>              </div>            </details><h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><ul><li>无序，添加和取出顺序不同。</li><li>不允许重复元素，最多只有一个null</li><li>可以用collection的方法</li><li>不能使用索引的方法遍历。</li></ul><h3 id="重磅！HashSet"><a href="#重磅！HashSet" class="headerlink" title="重磅！HashSet"></a>重磅！HashSet</h3><div class="tip warning"><p>前方高能，非战斗人员迅速撤离</p></div><ul><li>底层实际上是HashMap。</li><li>不保证元素是有序的，取决于hash后，再确定索引的结果。</li></ul><span class='p red'>经典面试题：下面加入了几个元素？</span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hashset = <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">hashset.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hsp&quot;</span>));</span><br><span class="line">hashset.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hsp&quot;</span>));</span><br><span class="line">System.out.println(hashset);</span><br></pre></td></tr></table></figure><p>答案：只加入了一个。分析：就要来看底层add()的机制了！</p><details class="folding-tag" blue><summary> HashSet底层--先说结论 </summary>              <div class='content'>              <p>底层是邻接表！</p><ol><li>HashSet底层是HashMap，HashMap的底层是—》数组 + 链表 + 红黑树</li><li>add()一个元素的时候顺序如下</li></ol><ul><li>先得到hash值—&gt;转成索引。</li><li>找到数据表table，看这个索引位置是否已经存放元素。<ul><li>如果没有，直接加入。</li></ul></li><li>如果有，调用equals方法。<ul><li>equals方法中（由程序员确定），看具体对象的重写。</li><li>如果相同，就放弃添加。</li><li>如果不相同，则添加到链表最后。</li></ul></li></ul><p>在JDK8中，如果一条链表的个数到达TREEFY_THRESHOLD(默认8)<br>并且table的大小&gt;=MIN_TREEFY_CAPACITY(64)就会将链表进行树化。<br>把链表转化为红 黑 树！</p>              </div>            </details><details class="folding-tag" red><summary> HashSet底层--再看底层代码 </summary>              <div class='content'>              <ol><li>add(e) 执行 return map.put(e,PRESENT) == null // PRESENT是hashset的一个final静态对象，是一个占位作用的Object对象。也就是说key是变化的，value是一个共享的PRESENT。</li><li>map.put(e,PRESENT)会执行：return putVal(hash(key),key,value,false,true);<ol><li>其中hash(Object key) — &gt; return (key==null)?0 : (h=key.hashcode())^(h&gt;&gt;&gt;16)  是计算哈希值的算法，可以尽量避免冲突。</li></ol></li><li>putVal(int hash, K key , V value, boolean onlyIfAbsent, boolean evict)<ol><li>其中resize()方法用于扩容！</li></ol></li></ol><p>下面请欣赏putVal的代码解析：<br>final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) {<br>    Node<K,V>[] tab; Node<K,V> p; int n, i; // 辅助变量,//table—放Node结点的数组，即邻接表<br>    //如果table为空或者大小为0，第一次扩容为16个空间。<br>    if ((tab = table) == null || (n = tab.length) == 0)<br>        n = (tab = resize()).length; //table这里就变成16的大小了<br>    //辅助变量p: 根据传入的key得到的hash值，去计算key应该存放到table表的哪个索引,这个位置的对象赋值给p<br>    //再判断p是否为空<br>    if ((p = tab[i = (n - 1) &amp; hash]) == null)<br>            tab[i] = newNode(hash, key, value, null);<br>            //，如果是空，表示没存放过数据。那么创建新结点(hash,key,value,null)存放hash只为了将来equals用<br>        else {<br>            //如果p不是空，比如第二次插入java这个字符串。<br>            Node<K,V> e; K k;<br>    //如果：当前索引位置对应的链表的【第一个元素】和准备添加的key的hash值一样<br>    //【并且】满足（准备加入的key 和 p指向的Node结点的key是同一个对象）.【或者】（p指向的Node结点的key的equals方法和准备加入的key比较后相同）<br>    //就：不能加入。<br>            if (p.hash == hash &amp;&amp;<br>                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))<br>                e = p;<br>    //特判一下，p是不是一颗红黑树。如果是一颗红黑树，就调用putTreeVal()方法进行添加。里面有大量红黑树算法<br>            else if (p instanceof TreeNode)<br>                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);<br>    //走到这里表示：和第一个结点不一样<br>    else {<br>        //遍历链表，。<br>        //依次和该链表的每一个元素比较后，都不相同，则加到链表最后。<br>        //如果有相同情况，直接break<br>        for (int binCount = 0; ; ++binCount) { // 死循环<br>            if ((e = p.next) == null) { // 不比较头节点<br>                p.next = newNode(hash, key, value, null);<br>            if(tab == null||(n=tab.length) &lt; MIN_TREEIFY_CAPACITY)      resize()<br>            //在把元素添加到链表后，立即判断该链表是否已经达到8点<br>            //如果达到，对当前链表进行树化，转成红黑树。<br>            //注意，在进行树化时，会判断table的长度是否小于64。小于64不会真的树化，但是会resize()对数据表扩容。<br>            if (binCount &gt;= TREEIFY_THRESHOLD - 1) //&gt;=7 // -1 for 1st<br>                treeifyBin(tab, hash);<br>            break;<br>        }<br>            if (e.hash == hash &amp;&amp;((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))<br>                break;<br>            p = e;<br>        }<br>    }<br>    if (e != null) { // existing mapping for key<br>        V oldValue = e.value;<br>        if (!onlyIfAbsent || oldValue == null)<br>            e.value = value;<br>        afterNodeAccess(e);<br>        return oldValue; // 不返回空，代表失败。<br>    }<br>}<br>        ++modCount;<br>    //扩容临界值，在resize内是0.75*capacity = 12<br>        if (++size &gt; threshold)<br>            resize();<br>    //hashMap 留给子类重新实现，本身为空方法<br>        afterNodeInsertion(evict);<br>        return null; // 返回空代表成功！如果返回一个对象，代表有东西存在<br>    }</p>              </div>            </details><p>总结：</p><ol><li>第一次添加时，table数组扩容16，临界值threshold是16*0.75=12</li><li>如果table到达临界值，就会扩容到原来的两倍，也就是32.</li><li>扩容机制：我现在凌晨在这里追底层代码，就是为了确认，当你重写hashcode使得某个对象加入到set中处于同一条链表，当链表节点超过8时，每加入一次会对表进行扩容。比如添加第9个数据，表会扩容到32，第10个就会64，然后添加第11个就会变成红黑树。</li><li>保证某类对象满足某些条件就无法加入hashmap：重写hashcode和equals方法。</li></ol><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><ol><li>属于HashSet的子类。</li><li>底层是LinkedHashMap，维护的是：数组 + 双链表。</li><li>根据hashcode决定元素存储位置，同时维护元素的次序，这使得元素看起来是按照插入顺序进行排序的。</li><li>不允许添加重复元素。</li></ol><p>底层细节：</p><ul><li>LinkedHashSet中维护一个哈希表 + 双向链表。在LinkedHashSet中有head和tail节点。</li><li>每一个节点，都有一个before|after属性，可以形成双链表。</li><li>在添加一个元素的时候<ul><li>先求哈希值，再求索引。</li><li>确定该元素在table中的位置，然后将这个节点添加到双向链表中。</li><li>tail.next = newElement;newElement.pre = tail; tail = newElement;</li></ul></li><li>遍历LinkedHashSet也能保证插入顺序和遍历顺序相同。</li></ul><p>底层结构：</p><ul><li>table第一次添加初始化为16.</li><li>table的类型是内部类，HashMap$Node</li><li>节点的类型是LinkedHashMap$Entry,不是Node</li><li>这么存放体现了多态现象。—Entry继承了HashMap.Node</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA后端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础篇--OOP(3)</title>
      <link href="/2023/01/09/230108JavaBasic4/"/>
      <url>/2023/01/09/230108JavaBasic4/</url>
      
        <content type="html"><![CDATA[<h1 id="Java阶段1—Java基础篇—-gt-OOP-3"><a href="#Java阶段1—Java基础篇—-gt-OOP-3" class="headerlink" title="Java阶段1—Java基础篇—&gt;OOP(3)"></a>Java阶段1—Java基础篇—&gt;OOP(3)</h1><h2 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h2><ol><li>static:类变量和类方法</li><li>理解main方法语法</li><li><strong>CodeBlock代码块</strong></li><li>设计模式—单例模式</li><li>final关键字</li><li>abstract:抽象类</li><li><strong>interface:接口</strong></li><li><strong>InnerClass内部类</strong></li></ol><h2 id="static-类变量和类方法"><a href="#static-类变量和类方法" class="headerlink" title="static:类变量和类方法"></a>static:类变量和类方法</h2><h3 id="类变量定义"><a href="#类变量定义" class="headerlink" title="类变量定义"></a>类变量定义</h3><p>类变量，又叫静态变量，最大特点是会被所有对象实例共享。<br>静态变量在类加载的时候就生成。</p><h3 id="类变量的内存布局"><a href="#类变量的内存布局" class="headerlink" title="类变量的内存布局"></a>类变量的内存布局</h3><p>JDK8以前放在方法区，JDK8以后放在堆内，通过反射机制加载class对象。</p><h3 id="类变量的注意事项"><a href="#类变量的注意事项" class="headerlink" title="类变量的注意事项"></a>类变量的注意事项</h3><ol><li>定义推荐顺序：public static int a = 10;</li><li>使用：类名.方法</li><li>重点：类变量在类加载的时候就初始化，生命周期是随着类的加载而开始，随着类的消亡而消亡。</li></ol><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>使用场景：不需要实例化对象，用于工具类使用。<br>例如：Math类、Array类、Collections类<br>注意事项：</p><ol><li>类方法随着类的加载而加载。</li><li>不允许使用与对象有关的关键字：super 和 this。</li><li><strong>类方法中只能访问静态变量和静态方法</strong>。</li><li>普通的成员方法可以访问普通属性和方法，也可以访问静态的属性和方法。</li></ol><h2 id="理解Main方法的语法"><a href="#理解Main方法的语法" class="headerlink" title="理解Main方法的语法"></a>理解Main方法的语法</h2><h3 id="main方法的机制"><a href="#main方法的机制" class="headerlink" title="main方法的机制"></a>main方法的机制</h3><ol><li>public: main方法用JVM调用。</li><li>static: JVM在执行main方法时，没必要创建对象。</li><li>String[] args: 该方法接受String数组参数，该数组中保存了执行java命令时候传递给所运行类的参数。</li></ol><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><ol><li>作为静态方法，main方法中可以直接调用main所在类的静态方法和静态属性。</li><li>作为静态方法，main方法同理不能访问类中非静态成员，必须实例化对象。</li></ol><h2 id="❤️‍🔥CodeBlock"><a href="#❤️‍🔥CodeBlock" class="headerlink" title="❤️‍🔥CodeBlock"></a>❤️‍🔥CodeBlock</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>属于类的成员，将逻辑语句封装到{}中。<br>没有方法名、返回、参数，无法显式调用，而是加载类时隐式调用。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>修饰符可选，只能用static。以此分为静态代码块和普通代码块。</p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ol><li>对构造器的补充机制，可以做初始化操作。</li><li>如果多个构造器有重复代码的话，可以抽取到块中，提高复用。</li><li>调用机制：<strong>先代码块后调用构造器</strong>。—见下方介绍</li></ol><h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h3><ol><li>静态代码块随着类加载而执行，<strong>只会执行一次</strong>！如果是<strong>普通代码块，每创建一个对象就执行</strong>。如果只使用类的静态成员，普通代码块不会被调用。</li><li>❤️‍🔥<strong>类加载的时机</strong>：<ol><li>new一个对象时。</li><li>new一个子类时，父类也会被加载。而且父类先被加载！</li><li>使用类的静态成员时。</li></ol></li><li>❤️‍🔥创建一个对象时，<strong>类的调用顺序</strong>是：<ol><li>调用静态代码块和静态属性。（静态代码块和静态属性<strong>初始化</strong>调用优先级同，看定义顺序）</li><li>调用普通代码块和普通属性。（普通代码块和普通属性<strong>初始化</strong>调用优先级同，看定义顺序）</li><li>调用构造器。</li></ol></li><li>构造器前面隐含了两句话: super() 和普通代码块。</li><li>❤️‍🔥❤️‍🔥创建一个子类对象时，各内容的调用顺序：<ol><li>父类的静态代码块和静态属性初始化。</li><li>子类的静态代码块和静态属性初始化。</li><li>父类的普通代码块和普通属性初始化。</li><li>父类的构造器。</li><li>子类的普通代码块和普通属性初始化。</li><li>子类的构造器。</li></ol></li><li>静态代码块只能调用静态成员，普通代码块能调用任意成员。</li></ol><h2 id="设计模式—单例设计模式"><a href="#设计模式—单例设计模式" class="headerlink" title="设计模式—单例设计模式"></a>设计模式—单例设计模式</h2><h3 id="什么是设计模式？"><a href="#什么是设计模式？" class="headerlink" title="什么是设计模式？"></a>什么是设计模式？</h3><p>设计模式是在大量实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式就像是经典的棋谱，不同的棋局，我们用不同的棋谱，免去我们自己思考和摸索。</p><h3 id="什么单例模式？"><a href="#什么单例模式？" class="headerlink" title="什么单例模式？"></a>什么单例模式？</h3><p>采取一定的方法保证整个软件系统中，对<strong>某个类只能存在一个对象实例</strong>，并且该类只提供一个取得其对象实例的方法。<br>两种方式：饿汉模式 和 懒汉模式</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><ol><li>构造器私有化。防止new一个对象。</li><li>类内部创建对象。</li><li>向外提供静态的公共方法。</li><li>代码实现。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GirlFriend</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">GirlFriend</span> <span class="variable">girlfriend</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GirlFriend</span>(<span class="string">&quot;Sonia&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GirlFriend</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GirlFriend <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> girlfriend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉模式在类加载时对象就创建了，有可能不需要用到这个对象的，但是已经创建了。</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><ol><li>构造器私有化。</li><li>定义一个static的对象。但是<strong>没有new!</strong></li><li>提供接口返回对象。</li><li>唯一区别：只有当用户调用接口时，才会返回对象。如果再次调用会返回上次的对象。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Cat cat; <span class="comment">// 没有new！</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Cat</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Cat <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cat == <span class="literal">null</span>) cat = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="饿汉式-VS-懒汉式"><a href="#饿汉式-VS-懒汉式" class="headerlink" title="饿汉式 VS 懒汉式"></a>饿汉式 VS 懒汉式</h3><ol><li>最大区别：创建对象时机不同，饿汉在类加载就创建，懒汉在使用才创建。</li><li>安全问题：饿汉式不存在线程安全；懒汉式存在线程安全问题。</li><li>资源：饿汉式存在浪费资源的可能。懒汉式不存在这个问题。</li><li>javaSE标准类中，RunTime就使用了饿汉模式。</li></ol><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>修饰：</p><ol><li>类：不希望类被继承。</li><li>方法：不希望父类的某个方法被子类重写。</li><li>属性和局部变量：不希望被修改。</li></ol><h3 id="使用细节-1"><a href="#使用细节-1" class="headerlink" title="使用细节"></a>使用细节</h3><ol><li>常量一般用全大写。</li><li>final修饰时候必须初始化。初始化位置可以是：<ol><li>定义时候直接赋值。</li><li>构造器中。</li><li>代码块中。</li></ol></li><li>final修饰静态，初始化位置要么是直接赋值要么是静态代码块中。</li><li>final方法虽然不能重写，但是可以继承。</li><li>一般来讲，如果final修饰了类，就没必要修饰方法了。既然都无法继承了，还怕被重写吗？</li><li>final不能修饰构造器。</li><li><strong>final和static往往搭配使用，效率更高，不会导致类加载。</strong></li></ol><p>这里有一个例子：在这里final和static一起用，加载B类，也就不会输出静态代码块的内容。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">999</span>;</span><br><span class="line">    staic&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is B&#x27;s static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下为main方法内</span></span><br><span class="line">System.out.println(B.num);</span><br></pre></td></tr></table></figure></p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>abstract关键字，抽象类价值在于设计，让子类重写实现抽象类。</p><h3 id="细节-1"><a href="#细节-1" class="headerlink" title="细节"></a>细节</h3><ol><li>抽象类不可以被实例化。</li><li>一旦写了抽象方法，这个类就是抽象类。但抽象类可以没有抽象方法。</li><li>abstract只能修饰类和方法，不能修饰其它。 </li><li>抽象类本质还是类，可以拥有非抽象方法，构造器，静态属性。</li><li>抽象方法不能有主体。</li><li>如果一个类继承了抽象类，那就必须实现抽象类内所有抽象方法。除非自己也是抽象类。</li><li><strong>抽象方法不能用private static final修饰。</strong><ol><li>private:私有了还重写个P。</li><li>static: 你都没主体，那外部直接调用static方法实现个P。</li><li>final: 无法继承还抽象个P。</li></ol></li></ol><h3 id="设计模式—模板设计模式（抽象类最佳实践）"><a href="#设计模式—模板设计模式（抽象类最佳实践）" class="headerlink" title="设计模式—模板设计模式（抽象类最佳实践）"></a>设计模式—模板设计模式（抽象类最佳实践）</h3><ol><li>设计一个抽象类Template<ol><li>编写calculateTime()计算某段代码的耗时时间。</li><li>编写抽象方法job()</li></ol></li><li>编写子类Sub继承抽象类并实现job方法。</li><li>编写一个测试类进行测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculateTiem</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        job(); <span class="comment">// 动态绑定机制，不同子类调用时，执行的是不同的job</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行时间 &quot;</span> + (end - start));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AA</span> <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">800000</span>; i++) &#123;</span><br><span class="line">            num+=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTemplate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AA</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA</span>();</span><br><span class="line">        aa.calculateTime(); <span class="comment">// 这里还是需要有良好的OOP基础，尤其是对多态动态绑定机制的理解</span></span><br><span class="line">        <span class="type">BB</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line">        bb.calculateTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="❤️‍🔥Interface"><a href="#❤️‍🔥Interface" class="headerlink" title="❤️‍🔥Interface"></a>❤️‍🔥Interface</h2><p>给出一些没有实现的方法，封装到一起，当某类要使用再具体实现。<br>语法：interface 接口名{属性 方法} 方法可以为抽象、默认、静态</p><ul><li>jdk7.0前，接口中所有方法都是抽象方法</li><li>jdk8.0后，可以有静态方法和默认方法。<br>实现：关键字implements</li></ul><h3 id="应用场景—控制软件的质量和规范"><a href="#应用场景—控制软件的质量和规范" class="headerlink" title="应用场景—控制软件的质量和规范"></a>应用场景—控制软件的质量和规范</h3><p>以连接三个不同的数据库为例，用接口可以实现方法名的统一。</p><h3 id="细节-2"><a href="#细节-2" class="headerlink" title="细节"></a>细节</h3><ol><li>与抽象类相同，无法实例化。</li><li>与类相同，接口的修饰符只能是public 或者 无修饰。</li><li>所有方法都是public abstract 所以可以不用写。</li><li>普通类如果实现接口，必须实现接口的所有方法。快捷键：alt + enter</li><li>抽象类实现接口，可以不实现方法。</li><li>不同于继承，一个类可以实现多个接口。</li><li><strong>接口中的属性，只能是final，而且是public static final修饰符。</strong></li><li>因此，接口属性的访问方式：接口名.属性名</li><li>一个接口不能继承其它类，但可以继承其它接口。</li></ol><h3 id="接口与继承的比较"><a href="#接口与继承的比较" class="headerlink" title="接口与继承的比较"></a>接口与继承的比较</h3><ol><li>解决问题不同：<ul><li>继承解决：代码复用性和可维护性。</li><li>接口解决：设计和规范。</li></ul></li><li>灵活性：接口比继承更灵活。<ul><li>继承：is a 的关系。</li><li>接口：like a 的关系</li></ul></li><li>接口在一定程度上实现代码解耦。<br>（接口规范性+配合动态绑定机制，实现解耦。）</li></ol><h3 id="❤️‍🔥接口的多态特性"><a href="#❤️‍🔥接口的多态特性" class="headerlink" title="❤️‍🔥接口的多态特性"></a>❤️‍🔥接口的多态特性</h3><ol><li>多态参数：接受一个接口参数，可以传入其他具体的类。形参是接口，实参是类。</li><li>多态数组：一个接口类型数组，每一个位置可以存放一个不同的类对象，遍历的时候可以执行各自的特有方法和实现了接口的公有方法。</li><li>接口存在多态传递现象：IG继承了IH，teacher实现了IG，相当于实现了IH。</li></ol><h2 id="❤️‍🔥❤️‍🔥❤️‍🔥内部类"><a href="#❤️‍🔥❤️‍🔥❤️‍🔥内部类" class="headerlink" title="❤️‍🔥❤️‍🔥❤️‍🔥内部类"></a>❤️‍🔥❤️‍🔥❤️‍🔥内部类</h2><p>类的五大成员：属性、方法、构造器、代码块、内部类。<br>内部类最大特点：直接访问外部类私有属性，体现类和类的包含关系。<br>分类：</p><ul><li>外部类的方法内<ul><li>局部内部类</li><li>❤️‍🔥❤️‍🔥❤️‍🔥匿名内部类</li></ul></li><li>外部类位置<ul><li>成员内部类</li><li>静态内部类</li></ul></li></ul><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>定义在外部类的局部位置，比如方法和代码块中，并且有类名。</p><h4 id="细节-3"><a href="#细节-3" class="headerlink" title="细节"></a>细节</h4><ol><li>能直接访问外部类成员，包括私有。</li><li>地位：局部变量。无法添加访问修饰符。但是可以final。</li><li>作用域：代码块和方法。</li><li>访问：<ol><li>外部类（作用域内） 访问 局部内部类：new对象。</li><li>局部内部类 访问 外部类：直接访问。</li><li>外部其它类 无法访问 局部内部类。</li></ol></li><li>命名：<ol><li>如果外部类和局部内部类重名，就近原则。 </li><li>访问外部类：外部类名.this.成员</li><li>解读：外部类名.this就是外部类的实例对象。</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> n1= <span class="number">200</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> f1&#123;</span><br><span class="line">                <span class="comment">//方法体</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.f1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="❤️‍🔥❤️‍🔥❤️‍🔥匿名内部类"><a href="#❤️‍🔥❤️‍🔥❤️‍🔥匿名内部类" class="headerlink" title="❤️‍🔥❤️‍🔥❤️‍🔥匿名内部类"></a>❤️‍🔥❤️‍🔥❤️‍🔥匿名内部类</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ol><li>本质是类。</li><li>是内部类。</li><li>没有名字：表面上没有，其实系统分配了名字并隐藏了。</li><li>❤️‍🔥<strong>同时是一个对象。</strong></li></ol><p>语法：<br>new 类/接口(参数列表)<strong>{//类体};</strong></p><h4 id="基于接口的匿名内部类—匿名对象类实现了接口"><a href="#基于接口的匿名内部类—匿名对象类实现了接口" class="headerlink" title="基于接口的匿名内部类—匿名对象类实现了接口"></a>基于接口的匿名内部类—匿名对象类实现了接口</h4><ol><li>需求：使用IA接口并创建对象，但是这个对象只用一次，专门写个类来实现接口不划算。</li><li>编译类型：接口类型IA</li><li>运行类型：匿名内部类—系统自动命名（可以用.getClass()查看）</li><li>JDK底层在创建匿名内部类后就立即<strong>创建了一个实例！</strong></li><li>匿名内部类使用一次就不再使用了，但是引用可以反复使用。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">IA</span> <span class="variable">tiger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IA</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;tiger is crying.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        tiger.cry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于类的匿名内部类—匿名对象类继承了父类"><a href="#基于类的匿名内部类—匿名对象类继承了父类" class="headerlink" title="基于类的匿名内部类—匿名对象类继承了父类"></a>基于类的匿名内部类—匿名对象类继承了父类</h4><ol><li>编译类型：父类</li><li>运行类型：匿名对象类</li><li>参数列表会拆传给父类的构造器。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is father&#x27;s constructor,and I receive  &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">father</span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Override father&#x27;s test&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        father.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于抽象类的匿名内部类—必须重写方法"><a href="#基于抽象类的匿名内部类—必须重写方法" class="headerlink" title="基于抽象类的匿名内部类—必须重写方法"></a>基于抽象类的匿名内部类—必须重写方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类最佳实践：做实参直接传递"><a href="#匿名内部类最佳实践：做实参直接传递" class="headerlink" title="匿名内部类最佳实践：做实参直接传递"></a>匿名内部类最佳实践：做实参直接传递</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cagur.innerclass;</span><br><span class="line"><span class="keyword">import</span> com.cagur.abstract_.AA;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClassExercise01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 2023/1/6 当作实参直接传递，简洁高效</span></span><br><span class="line">        <span class="comment">//如果我们传入一个匿名内部类</span></span><br><span class="line">        f1(<span class="keyword">new</span> <span class="title class_">IL</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;这是十分简洁的匿名内部类的show方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(IL il)</span>&#123;</span><br><span class="line">        il.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IL</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>定义在外部类成员位置，并且没有static修饰。<br>介绍：</p><ol><li>同样的，也可以直接访问外部类成员。</li><li>地址是成员：可以添加修饰符。</li><li>调用方式：在外部类成员方法中new一个内部类对象，再调用内部类对象的方法。 </li><li>访问：<ol><li>内 访问 外： 直接</li><li>外 访问 内：new</li><li>外部其它类 访问 成员内部类：<ol><li>Outer.Inner inner = outer.new Inner();</li><li>Outer.Inner inner = outer.getInnerInstance();</li><li>Outer.Inner inner = new Outer.new Inner();</li></ol></li></ol></li><li>外部类和内部类重名—就近原则。想访问外部类：外部类名.this.成员</li></ol><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>定义在外部类成员位置，用static修饰。<br>使用：</p><ol><li>可以直接访问外部类所有静态成员，但是无法访问非静态。</li><li>可以添加四种修饰符。</li><li>访问：<ol><li>内 访问 外： 直接</li><li>外 访问 内：类名.成员</li><li>外部其类 访问 静态内部类<ol><li>Outer.Inner inner = new Outer.Inner();</li><li>Outer.Inner inner = outer.getInnerInstance();</li><li>Outer.Inner inner = Outer.getInnerInstance();//因为是静态的</li></ol></li></ol></li><li>重名仍然就近原则，想访问外部类直接：外部类名.成员。</li></ol><blockquote><p>❤️‍🔥❤️‍🔥由此，Java基础的OOP阶段终于完结撒花啦！❤️‍🔥❤️‍🔥</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA后端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础篇--OOP(2)</title>
      <link href="/2023/01/08/230108JavaBasic3%20copy/"/>
      <url>/2023/01/08/230108JavaBasic3%20copy/</url>
      
        <content type="html"><![CDATA[<h1 id="Java阶段1—Java基础篇—-gt-OOP-2"><a href="#Java阶段1—Java基础篇—-gt-OOP-2" class="headerlink" title="Java阶段1—Java基础篇—&gt;OOP(2)"></a>Java阶段1—Java基础篇—&gt;OOP(2)</h1><h2 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h2><ol><li>IDEA快捷键</li><li>Package:包</li><li>访问修饰符</li><li>OOP三大特性之封装</li><li>OOP三大特性之继承</li><li>OOP三大特性之多态</li><li>super关键字</li><li>Overwrite</li><li>Object类</li><li>断点调试</li></ol><h2 id="IDEA快捷键"><a href="#IDEA快捷键" class="headerlink" title="IDEA快捷键"></a>IDEA快捷键</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">删除当前行: CTRL + Y</span><br><span class="line">复制当前行并粘贴: CTRL + D</span><br><span class="line">补全代码行: ALT + /</span><br><span class="line">*导入该行需要的类: ALT + ENTER</span><br><span class="line">快速格式化代码: CTRL + ALT + L</span><br><span class="line">运行: SHIFT + F5</span><br><span class="line">*生成构造器等: CTRL + ALT + INSERT</span><br><span class="line">*查看类的层级关系: CTRL + H</span><br><span class="line">*将光标放在一个方法上，输入 CTRL + B可以定位到具体类。</span><br><span class="line">自动分配变量名\for语句等模板：.var .fori</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>作用:</p><ol><li>区分相同名字的类</li><li>当类很多时，可以很好管理类。</li><li>控制访问范围。</li></ol><p>本质:创建不同的文件夹保存类文件。<br>解释:在com.cagur.a com.cagur.b中都存在Person类，如果在另外一个文件中要使用Person类，就要import 如果带上包名就不用import。但是只能有一个是不带包名的。</p><h3 id="包的命名规范"><a href="#包的命名规范" class="headerlink" title="包的命名规范"></a>包的命名规范</h3><p>小写字母 + 圆点<br>一般为com.公司名.项目名.业务模块名</p><h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h3><ul><li>import java.util.Scanner 只引入这一个类<ul><li>import java.util.* 表示引入这个包下所有类</li><li>建议：需要使用哪个类就导入哪个类即可，不要使用*</li></ul></li><li>package放在类最上面用来打包，一个类最多有一个package，import放package下</li></ul><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><div class="table-container"><table><thead><tr><th style="text-align:center">访问控制修饰符</th><th style="text-align:center">同类</th><th style="text-align:center">同包</th><th style="text-align:center">子类</th><th style="text-align:center">不同包</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:center">🆗</td><td style="text-align:center">🆗</td><td style="text-align:center">🆗</td><td style="text-align:center">🆗</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">🆗</td><td style="text-align:center">🆗</td><td style="text-align:center">🆗</td><td style="text-align:center">❌</td></tr><tr><td style="text-align:center">无修饰</td><td style="text-align:center">🆗</td><td style="text-align:center">🆗</td><td style="text-align:center">❌</td><td style="text-align:center">❌</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">🆗</td><td style="text-align:center">❌</td><td style="text-align:center">❌</td><td style="text-align:center">❌</td></tr></tbody></table></div><p>同一个类中，无论什么访问权限都能自由访问。<br>同一个包中，除了private其它都能访问。</p><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><ol><li>修饰符支持修饰类的属性、成员方法和类。</li><li>类只能用无修饰和public来修饰。</li></ol><h2 id="Encapsulation-封装"><a href="#Encapsulation-封装" class="headerlink" title="Encapsulation 封装"></a>Encapsulation 封装</h2><p>定义：数据被保护在内部，隐藏实现细节，只有通过调用提供的方法才能访问。<br>好处：可以对传入的数据进行验证。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>将属性设为private</li><li>提供public的set方法，用于判断并赋值。—加入数据验证的业务逻辑。</li><li>提供public的get方法，用于获取属性值。—加入权限判断的业务逻辑。</li></ol><p>set方法写在构造器中，仍然可以进行验证数据。</p><h2 id="Extend-继承"><a href="#Extend-继承" class="headerlink" title="Extend 继承"></a>Extend 继承</h2><p>好处：提高了代码复用性、代码扩展性和维护性。</p><h3 id="继承的细节"><a href="#继承的细节" class="headerlink" title="继承的细节"></a>继承的细节</h3><ol><li>继承是全继承。子类继承了父类所有成员，但是private的成员不能直接访问。除非通过父类提供的公共方法访问。</li><li>子类必须调用父类构造器。子类构造器隐藏了: super(); 即调用默认调用父类的无参构造。</li><li><strong>如果父类不提供无参构造器，则必须在子类构造器中用super指定父类的哪个构造器完成对父类的初始化工作！</strong></li><li>super必须放在子类构造器的第一行！</li><li>super() 和 this() 都只能放构造器第一行，因此不能共存于同一个构造器。</li><li>Object是所有类的基类。</li><li>父类构造器的调用不限于直接父类，将一直向上追溯到Object</li><li>单继承机制：子类最多继承一个父类。</li><li>不能滥用继承，必须满足 is a 的关系</li></ol><h3 id="继承的本质"><a href="#继承的本质" class="headerlink" title="继承的本质"></a>继承的本质</h3><p>建立一个查找关系！<br>方法区的加载顺序：从父到子。<br><strong>访问子类方法时候的查找顺序:</strong></p><ol><li>首先看子类是否有该属性。如果有且权限允许，就访问。</li><li>如果子类没有，就看父类是否有这个属性且权限允许，有就访问。</li><li>按照2的逻辑一直找到object</li><li>如果都没有就不行。如果找到其中一步但是访问权限为private，不会继续找，报错。</li></ol><h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>super代表父类引用，用于访问</p>]]></content>
      
      
      <categories>
          
          <category> JAVA后端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础篇--OOP(1)</title>
      <link href="/2023/01/08/230108JavaBasic2/"/>
      <url>/2023/01/08/230108JavaBasic2/</url>
      
        <content type="html"><![CDATA[<h1 id="Java阶段1—Java基础篇—-gt-OOP-1"><a href="#Java阶段1—Java基础篇—-gt-OOP-1" class="headerlink" title="Java阶段1—Java基础篇—&gt;OOP(1)"></a>Java阶段1—Java基础篇—&gt;OOP(1)</h1><h2 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h2><ol><li>对象在内存的简单布局</li><li>Field:属性\成员变量\字段</li><li>Method:成员方法</li><li>Overload:重载</li><li>VarParameter:可变参数</li><li>Scope:作用域</li><li>Constructor:构造器</li><li>this关键字</li></ol><h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><p>栈区：存放局部变量。<br>堆区：存放对象。<br>方法区：常量池（存储字符串常量）、加载类信息（属性 + 行为）</p><h2 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h2><h3 id="对象分配机制"><a href="#对象分配机制" class="headerlink" title="对象分配机制"></a>对象分配机制</h3><p>引用类型赋值。Person p1= new Person(); p2 = p1;实际上指向同一块堆区地址。</p><h3 id="Java创建类流程"><a href="#Java创建类流程" class="headerlink" title="Java创建类流程"></a>Java创建类流程</h3><ol><li>加载类信息(属性和方法)</li><li>堆区分配空间，进行默认初始化</li><li>把地址赋值给引用</li><li>进行指定属性初始化</li></ol><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><h4 id="传参机制"><a href="#传参机制" class="headerlink" title="传参机制"></a>传参机制</h4><p>基本数据类型：值传递;   引用类型:传地址;</p><h4 id="克隆对象"><a href="#克隆对象" class="headerlink" title="克隆对象"></a>克隆对象</h4><p>传入一个对象，返回另一个成员相同但地址独立的对象。<br>在方法内new一个，进行属性赋值即可。</p><h2 id="Overload"><a href="#Overload" class="headerlink" title="Overload"></a>Overload</h2><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><p>概念：<strong>同一个类</strong>中，多个<strong>同名方法</strong>存在。这样做减少了起名麻烦、方便接口编程。<br>相同：方法名<br>不同：形参列表(形参<strong>类型</strong>、形参<strong>个数</strong>、形参<strong>顺序</strong>)<br>无要求：返回类型</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>sout可以输出不同类型的数据。</p><h2 id="VarParameter"><a href="#VarParameter" class="headerlink" title="VarParameter"></a>VarParameter</h2><p>概念：<strong>同一个类</strong>中多个<strong>同名同功能</strong>但是<strong>参数个数不同</strong>的方法。<br>注意事项：</p><ol><li>参数个数：可变参数的实参可为0个到任意多个。</li><li>本质：数组。因此可变参数实参可以是数组！</li><li>位置：可变参数可以和普通类型参数放在形参列表后，但是必须保证可变参数在最后。</li><li>一个形参列表只可以有一个可变参数。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Method</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>... nums)</span>&#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h2><ol><li>生命周期：成员变量（全局变量）-跟随类的创建和死亡。局部变量-伴随代码块执行而创建和死亡。</li><li>作用域：全局变量在本类用或对象在其它类调用;局部变量只能在本类某方法中用。</li><li>修饰符：全局变量可修饰符，局部变量无修饰符。</li></ol><h2 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h2><p>介绍：用于完成对新对象初始化的特殊类方法，无返回值，类名和方法名同，由系统调用。</p><ol><li>构造器支持重载。</li><li>构造器语法规则：跟类名相同，无返回值。</li><li>系统在创建对象时自动调用。</li><li>若不写，系统自动生成默认无参构造器。（反编译:javap）</li><li><strong>一旦定义自己有参构造器，将覆盖系统默认无参构造器，除非显式声明。</strong></li></ol><h4 id="对象创建流程再分析"><a href="#对象创建流程再分析" class="headerlink" title="对象创建流程再分析"></a>对象创建流程再分析</h4><ol><li>方法加载类信息。堆区开空间。</li><li>进行默认初始化：null\0。</li><li>进行显式初始化：90、abc…</li><li>执行构造器。</li><li>将对象的的引用返回给变量</li></ol><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><ol><li>this用来访问本类的属性、构造器、方法。</li><li>this用于区分当前类的属性和局部变量。</li><li>用this访问构造器只能<strong>在构造器</strong>中使用，并且放在<strong>第一条</strong>语句！</li><li>this不能在类的外部使用，只能在类定义的方法中使用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JAVA后端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础搜索与图论-DFS、BFS、图和树的两种遍历、图和树的存储、拓扑排序</title>
      <link href="/2023/01/07/230101%E7%AE%97%E6%B3%951_7/"/>
      <url>/2023/01/07/230101%E7%AE%97%E6%B3%951_7/</url>
      
        <content type="html"><![CDATA[<h1 id="基础搜索和图论：DFS-BFS"><a href="#基础搜索和图论：DFS-BFS" class="headerlink" title="基础搜索和图论：DFS BFS"></a>基础搜索和图论：DFS BFS</h1><h2 id="1-基础DFS"><a href="#1-基础DFS" class="headerlink" title="1. 基础DFS"></a>1. 基础DFS</h2><p>DFS最重要的是：考虑什么样的顺序进行遍历。<br>重点概念：回溯、剪枝</p><h3 id="简单问题引入：数的全排列"><a href="#简单问题引入：数的全排列" class="headerlink" title="简单问题引入：数的全排列"></a>简单问题引入：数的全排列</h3><p>DFS结构如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> path[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == n)&#123;</span><br><span class="line">        <span class="comment">//搜索到当前节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,path[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//枚举全排列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(![st])&#123;</span><br><span class="line">            <span class="comment">//没走过</span></span><br><span class="line">            path[u] = i;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(u+<span class="number">1</span>);</span><br><span class="line">            st[i] = <span class="literal">false</span>;<span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="经典问题：N皇后问题"><a href="#经典问题：N皇后问题" class="headerlink" title="经典问题：N皇后问题"></a>经典问题：N皇后问题</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>n*n棋盘，任意皇后不可以在同一行、同一列、同一斜线。<br>输出满足条件的棋子摆法。</p><h4 id="搜索方式1：按行搜索，每行最多就放一个"><a href="#搜索方式1：按行搜索，每行最多就放一个" class="headerlink" title="搜索方式1：按行搜索，每行最多就放一个"></a>搜索方式1：按行搜索，每行最多就放一个</h4><p>基本属性：col[N]列是否存放;dg[N]斜对角;udg[N]斜对角线<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> col[N],dg[N],udg[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( u == n)&#123;</span><br><span class="line">        <span class="comment">//找到最后一行，输出地图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">puts</span>(g[i]); </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//搜索每一列</span></span><br><span class="line">        <span class="keyword">if</span>(!col[i] &amp;&amp; !dg[u+i] &amp;&amp; !udg[i-u +n])&#123;</span><br><span class="line">            <span class="comment">//如果满足条件，注意反对角线为了防止变成负数加个n</span></span><br><span class="line">            g[u][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            col[i] = dg[u+i] = udg[i-u+n] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(u+<span class="number">1</span>);</span><br><span class="line">            col[i] = dg[u+i] = udg[i-u+n] = <span class="literal">false</span>;</span><br><span class="line">            g[u][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="搜索方式2：争对每个格子有放和不放两种选择"><a href="#搜索方式2：争对每个格子有放和不放两种选择" class="headerlink" title="搜索方式2：争对每个格子有放和不放两种选择"></a>搜索方式2：争对每个格子有放和不放两种选择</h4><p><strong>dfs(x,y,z)</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">bool</span> row[N],col[N],dg[N],udg[N];</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y , <span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s &gt; n) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//枚举顺序，先枚举第一行第一列，再第二行</span></span><br><span class="line">    <span class="keyword">if</span>(y == n) y=,x++;</span><br><span class="line">    <span class="keyword">if</span>(x == n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == n)&#123; <span class="comment">//为目标</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">puts</span>(g[i]);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//两种选择：放/不放</span></span><br><span class="line">    <span class="comment">//不放</span></span><br><span class="line">    g[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(x,y+<span class="number">1</span>,s);</span><br><span class="line">    <span class="comment">//放</span></span><br><span class="line">    <span class="keyword">if</span>(!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x+y] &amp;&amp; !udg[x-y+n])&#123;</span><br><span class="line">        row[x] = col[y] = dg[x+y] = udg[x - y +n] = <span class="literal">true</span>;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(x,y+<span class="number">1</span>,s+<span class="number">1</span>);</span><br><span class="line">        g[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        row[x] = col[y] = dg[x+y] = udg[x - y + n] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-基础BFS"><a href="#2-基础BFS" class="headerlink" title="2. 基础BFS"></a>2. 基础BFS</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>如果边权均为1，则可以用来BFS来解决最短路问题。</p><h3 id="基本框架—以走迷宫为例"><a href="#基本框架—以走迷宫为例" class="headerlink" title="基本框架—以走迷宫为例"></a>基本框架—以走迷宫为例</h3><p><strong>题目描述</strong>：从(1,1)出发，每次只能向上下左右移动，问移动到(n,m)至少要移动多少次。<br>地图中0为可走，1为不可走。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> g[N][N],d[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;PII&gt;q;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="type">int</span> dx = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> nx = t.first + dx[i];</span><br><span class="line">            <span class="type">int</span> ny = t.second + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx &gt;=<span class="number">0</span> &amp;&amp; nx &lt;n; &amp;&amp; ny&gt;=<span class="number">0</span> &amp;&amp; ny&lt;m &amp;&amp; g[nx][ny]==<span class="number">0</span> &amp;&amp; d[nx][ny]==<span class="number">-1</span>)&#123;</span><br><span class="line">                d[nx][ny] = d[t.first][t.second]+<span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;nx,ny&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-图和树的存储及图和树的遍历"><a href="#3-图和树的存储及图和树的遍历" class="headerlink" title="3. 图和树的存储及图和树的遍历"></a>3. 图和树的存储及图和树的遍历</h3><h4 id="图和树的存储"><a href="#图和树的存储" class="headerlink" title="图和树的存储"></a>图和树的存储</h4><p>图：无向图和有向图。无向图可以看成是特殊的有向图，因此只需要考虑如何存储有向图。<br>存储图的手段一般用两种：稠密图用邻接矩阵，稀疏图用邻接表。邻接矩阵用g[a][b]存储a到b的信息，邻接表为每个节点开个单链表，存这个点可走到哪个节点。</p><h5 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h5><p>h[N]为n个链表头，e[M]存储值，ne[M]存储下一个节点，idx存储当前的节点。<br>初始化：头节点全部指向-1<br>插入a到b：在a的头节点头插一个b。</p><h4 id="深度优先遍历—例题引入：树的重心"><a href="#深度优先遍历—例题引入：树的重心" class="headerlink" title="深度优先遍历—例题引入：树的重心"></a>深度优先遍历—例题引入：树的重心</h4><h5 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h5><p>树的中心指树的一个节点，如果删掉此节点，使各个连通块内点数的最大值最小。</p><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>整体思路：求出每个点删掉后连通点的最大值，再在这一群最大值中求出最小值。<br>如何求删掉后点数最大：一分为二（子树：深搜返回；上方的连通块：n-下方-自己）</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-KMP、Trie树、并查集、堆</title>
      <link href="/2023/01/07/230101%E7%AE%97%E6%B3%951_5/"/>
      <url>/2023/01/07/230101%E7%AE%97%E6%B3%951_5/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构：KMP算法、Trie树、并查集、堆"><a href="#数据结构：KMP算法、Trie树、并查集、堆" class="headerlink" title="数据结构：KMP算法、Trie树、并查集、堆"></a>数据结构：KMP算法、Trie树、并查集、堆</h1><h2 id="1-KMP算法"><a href="#1-KMP算法" class="headerlink" title="1. KMP算法"></a>1. KMP算法</h2><h3 id="题目引入"><a href="#题目引入" class="headerlink" title="题目引入"></a>题目引入</h3><p>给字符串S，模式串P，只包含英文字母和数字，P作为S的子串多次出现。<br>求P在S中所有出现位置的起始下标。</p><h3 id="暴力做法？"><a href="#暴力做法？" class="headerlink" title="暴力做法？"></a>暴力做法？</h3><p>每次匹配失败，只向后移动一位。<br>问题：有很多信息没有被利用，有被优化的空间。<br><strong>思考</strong>：最少移动多少使得【前缀】和【后缀】相等。<br>由于前缀和后缀只与<strong>匹配串</strong>有关，因此思考能否<strong>预处理</strong>出【最长的后缀】且与前缀相等。*</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>s[] 模式长串    p[]模板串<br>next[i]=j;表示；以i为终点的后缀 和 从1开始的前缀长度相等且最长，长度为j<br>当s[i]!=p[j+1]时候，需要移动next[j]的距离。</p><h3 id="核心思想：next数组—退一步海阔天空！"><a href="#核心思想：next数组—退一步海阔天空！" class="headerlink" title="核心思想：next数组—退一步海阔天空！"></a>核心思想：next数组—退一步海阔天空！</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//给大脑一个理解的时间，隔了很久之后重新看KMP突然感觉理解更深入了。</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>,M = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> p[N],s[M];</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p+<span class="number">1</span> &gt;&gt; m &gt;&gt; s+<span class="number">1</span>; <span class="comment">// KMP下标从1开始</span></span><br><span class="line">    <span class="comment">//求next数组过程--也是退而求其次不断地 j= ne[j]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;i++)&#123; <span class="comment">// ne[1] = 0</span></span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; p[i]!=p[j+<span class="number">1</span>]) j =ne[j]; <span class="comment">//不匹配，后退</span></span><br><span class="line">        <span class="keyword">if</span>(p[i] == p[j+<span class="number">1</span>]) j++; <span class="comment">//匹配成功，向下走</span></span><br><span class="line">        ne[i] = j; <span class="comment">// 记录next数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//KMP匹配过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=m;i++)&#123;  <span class="comment">//试图与s[i]匹配的是p[j+1]</span></span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; s[i]!=p[j+<span class="number">1</span>])&#123; <span class="comment">// j没有退回起点 并且 匹配失败</span></span><br><span class="line">            j=ne[j]; <span class="comment">//移动到next[j]的位置。理解：看ne[j]的含义。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i]== p[j+<span class="number">1</span>]) j++; <span class="comment">// KMP思想：j每次如果无法匹配就退1步，如果可以匹配就继续走。</span></span><br><span class="line">        <span class="keyword">if</span>( j == n)&#123;</span><br><span class="line">            <span class="comment">//匹配成功</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i-n+<span class="number">1</span> <span class="number">-1</span>); <span class="comment">//  向下走</span></span><br><span class="line">            j = ne[j];<span class="comment">// 匹配成功后，</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Trie树"><a href="#2-Trie树" class="headerlink" title="2. Trie树"></a>2. Trie树</h2><p><strong>Trie树主要用于：快速存储和查找字符串集合</strong></p><h3 id="题目引入-1"><a href="#题目引入-1" class="headerlink" title="题目引入"></a>题目引入</h3><p>维护字符串集合，支持插入字符串、询问字符串在集合中出现了多少次。</p><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p><strong>比较精妙的一点是idx的运用，跟链表类似！</strong><br>son[N][26] 存子节点;题目是26个字母的话，子节点最多就只有26条边<br>cnt[N] 存以当前结尾的单词的个数<br>操作：存储insert(char[])    查询query(char[])<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>]; <span class="comment">// 每个节点最多向外连接26条边，存每个节点的儿子</span></span><br><span class="line"><span class="type">int</span> cnt[N]; <span class="comment">//存以当前结尾的单词的个数</span></span><br><span class="line"><span class="type">int</span> idx;<span class="comment">//当前节点。 注意：下标是0的点是根节点和空节点</span></span><br><span class="line"><span class="comment">//存储操作，即插入操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;str[i];i++)&#123;<span class="comment">//字符串结尾是0</span></span><br><span class="line">        <span class="comment">//对于字符串上的每一个字母，如果当前节点不存在就创建节点</span></span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u] = ++idx;<span class="comment">//不存在则创建节点</span></span><br><span class="line">        p = son[p][u]; <span class="comment">// 往下走</span></span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++; <span class="comment">// 以这个点结尾的字符串个数多1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> str[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;str[i];i++)&#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 不存在</span></span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-模拟堆"><a href="#4-模拟堆" class="headerlink" title="4. 模拟堆"></a>4. 模拟堆</h2>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-哈希表和字符串哈希</title>
      <link href="/2023/01/07/230101%E7%AE%97%E6%B3%951_6/"/>
      <url>/2023/01/07/230101%E7%AE%97%E6%B3%951_6/</url>
      
        <content type="html"><![CDATA[<h1 id="算法基础：前缀和-差分"><a href="#算法基础：前缀和-差分" class="headerlink" title="算法基础：前缀和+差分"></a>算法基础：前缀和+差分</h1><h2 id="1-前缀和算法"><a href="#1-前缀和算法" class="headerlink" title="1. 前缀和算法"></a>1. 前缀和算法</h2><h3 id="一维前缀和；快速求原数组一段的和"><a href="#一维前缀和；快速求原数组一段的和" class="headerlink" title="一维前缀和；快速求原数组一段的和"></a>一维前缀和；快速求原数组一段的和</h3><p>如何快速初始化前缀和数列？s[i] = s[i-1] + a[i];<br>如何快速求原数组一段的和？对于区间[L,R]:S[r] - S[L-1]; 让S[0]=0<br>代码非常简单：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="comment">//前缀和下标都是从1开始的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="comment">//初始化前缀和数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) s[i] = s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="二维前缀和：快速求小矩形的面积（容斥原理思想）"><a href="#二维前缀和：快速求小矩形的面积（容斥原理思想）" class="headerlink" title="二维前缀和：快速求小矩形的面积（容斥原理思想）"></a>二维前缀和：快速求小矩形的面积（容斥原理思想）</h3><p>如何快速初始化前缀和数列？ s[i,j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1]  + a[i][j];<br>如何快速球以x1y1左上角和x2y2右下角的矩形和： S = S[x2,y2] - S[x2,y1-1] - S[x1-1,y2] + S[x1-1,y1-1]<br>提示：虽然快排在蓝桥杯用不到，但是以后的笔试面试中，面试官可能会让手写快排。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> a[N][N],s[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="type">int</span> a;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">            <span class="comment">//直接边读入边初始化前缀和数组</span></span><br><span class="line">            s[i][j] = s[i<span class="number">-1</span>][j] + s[i][j<span class="number">-1</span>] - s[i<span class="number">-1</span>][j<span class="number">-1</span>] + a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[x2][y2] - s[x2][y1<span class="number">-1</span>] - s[x1][y2<span class="number">-1</span>] + s[x1<span class="number">-1</span>][y1<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-差分算法—前缀和算法的逆运算"><a href="#2-差分算法—前缀和算法的逆运算" class="headerlink" title="2. 差分算法—前缀和算法的逆运算"></a>2. 差分算法—前缀和算法的逆运算</h2><p>作用：对于数组中[l,r]之间的元素，快速让每个元素都加上某个常数c。<br>原理：假想当前数组为前缀和数组，构造出原数组b[n],那么，要让a[l]到a[r]之间的数字都加上c，只需要让b[l]+c;并且让b[r+1]减去c。</p><h3 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>  N = <span class="number">100000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    b[l]+=c;</span><br><span class="line">    b[r+<span class="number">1</span>]-=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="comment">//将初始化当作是在i和i区间插入数字即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">insert</span>(i,i,a[i]);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> l,r,c;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r &gt;&gt; c;</span><br><span class="line">        <span class="built_in">insert</span>(l,r,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) b[i]+=b[i<span class="number">-1</span>];<span class="comment">//递推重新求和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维差分—差分矩阵"><a href="#二维差分—差分矩阵" class="headerlink" title="二维差分—差分矩阵"></a>二维差分—差分矩阵</h3><p>对b[x1][y1]+=c;b[x2+1][y1]-=c;b[x1][y2-1]-=c;b[x2+1][y2+1]+=c<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> a[N][N],b[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="comment">//差分核心</span></span><br><span class="line">    b[x1][y1]+=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y1]-=c;</span><br><span class="line">    b[x1][y2+<span class="number">1</span>]-=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y2+<span class="number">1</span>]+=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">insert</span>(i,j,i,j,a[i][j]);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;c);</span><br><span class="line">        <span class="built_in">insert</span>(x1,y1,x2,y2,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二维前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            b[i][j] = b[i<span class="number">-1</span>][j] + b[i][j<span class="number">-1</span>] - b[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i][j]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-位运算"><a href="#3-位运算" class="headerlink" title="3. 位运算"></a>3. 位运算</h2><h3 id="n的二进制表示中第k位是多少"><a href="#n的二进制表示中第k位是多少" class="headerlink" title="n的二进制表示中第k位是多少"></a>n的二进制表示中第k位是多少</h3><p>步骤：首先把第k位移动到最后一位，其次看最后一位是多少。</p><h3 id="【非常重要】lowbit运算"><a href="#【非常重要】lowbit运算" class="headerlink" title="【非常重要】lowbit运算"></a>【非常重要】lowbit运算</h3><p>功能：返回x的最后一位1开头的二进制数<br>例子：x = 101000  lowbit(x) = 1000<br>实现：x &amp; (-x)<br>作用：求1的个数—每次可以减一个1<br><strong>实例代码：求二进制中1的个数</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x) x-=<span class="built_in">lowbit</span>(x),res++;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-离散化"><a href="#4-离散化" class="headerlink" title="4. 离散化"></a>4. 离散化</h2><p>概念：将值域大个数小的数字映射到从0开始的自然数。<br>问题；</p><ol><li>a[]中有重复元素，必须去重操作。</li><li>如何算出离散化后的值？<br>思路：</li></ol><ul><li>unique函数可以去重并返回尾端点</li><li>可以二分查找某个数<br><strong>示例题目：在一个序列中给某位置上的数加上c后求某个区间和</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据范围：数据下标从-1e9到1e9，加上的数范围是1e5</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;<span class="comment">// 存放左右区间</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>; <span class="comment">// 离散后的数据范围</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],s[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;alls;    <span class="comment">//存放需要离散的数</span></span><br><span class="line">vector&lt;PII&gt;add,query;   <span class="comment">//存放的是需要进行添加和询问操作的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;    <span class="comment">// 二分查找</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid =  l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(alls[mid]&gt;=x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l  = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 注意：排完序下标就是映射的值</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;  <span class="comment">//n个操作，m个询问</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,c;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        add.<span class="built_in">push_back</span>(&#123;x,c&#125;);<span class="comment">//差分操作</span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(x);<span class="comment">//需要映射的数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        query.<span class="built_in">push_back</span>(&#123;l,r&#125;);<span class="comment">//虚伪呢</span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(l);<span class="comment">//需要映射的数字</span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去重操作：先排序后去重。</span></span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>());</span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>()),alls.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//添加操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item : add)&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">find</span>(item.first); <span class="comment">// 查找映射后的下标</span></span><br><span class="line">        a[x] += item.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理前缀和数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">1</span>;i&lt;=alls.<span class="built_in">size</span>();i++) s[i] = s[i<span class="number">-1</span>] + a[i];</span><br><span class="line">    <span class="comment">// 处理询问：一维前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item : query)&#123;</span><br><span class="line">        <span class="type">int</span>  l = <span class="built_in">find</span>(item.first);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">find</span>(item.second);</span><br><span class="line">        cout &lt;&lt; s[r] - s[l<span class="number">-1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-区间合并：贪心算法"><a href="#5-区间合并：贪心算法" class="headerlink" title="5. 区间合并：贪心算法"></a>5. 区间合并：贪心算法</h2>用去区间左端点进行排序。<br>维护的区间分成三种情况：子集、改变end、完全无交集。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;isotream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt;&amp;segs)</span></span>&#123;</span><br><span class="line">    vector&lt;PII&gt;res;</span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(),segs.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed =<span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> seg : segs)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ed &lt; seg.first)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st!=<span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st,ed&#125;);</span><br><span class="line">            st = seg.first;</span><br><span class="line">            ed = seg.sencond;</span><br><span class="line">        &#125;<span class="keyword">else</span> ed = <span class="built_in">max</span>(ed,seg.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(st!=<span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st,ed&#125;);</span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;PII&gt;segs;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> l ,r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        segs.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">merge</span>(segs);</span><br><span class="line">    cout &lt;&lt; segs.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-双指针算法求最长连续不重复子序列"><a href="#6-双指针算法求最长连续不重复子序列" class="headerlink" title="6. 双指针算法求最长连续不重复子序列"></a>6. 双指针算法求最长连续不重复子序列</h2>给定长度为n有序序列，求出最长的不包含重复的数的连续区间长度。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N  = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N],s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        s[a[i]]++;</span><br><span class="line">        <span class="keyword">while</span>(s[a[j]] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            s[a[j]]--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res,i-j+<span class="number">1</span>);<span class="comment">//循环结束i和j之间都没有重复元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt;  res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-链表、栈、队列</title>
      <link href="/2023/01/07/230101%E7%AE%97%E6%B3%951_4/"/>
      <url>/2023/01/07/230101%E7%AE%97%E6%B3%951_4/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构—模拟链表、栈、队列"><a href="#数据结构—模拟链表、栈、队列" class="headerlink" title="数据结构—模拟链表、栈、队列"></a>数据结构—模拟链表、栈、队列</h1><h2 id="1-数组模拟单链表"><a href="#1-数组模拟单链表" class="headerlink" title="1. 数组模拟单链表"></a>1. 数组模拟单链表</h2><h3 id="为啥用数组模拟，不用结构体？"><a href="#为啥用数组模拟，不用结构体？" class="headerlink" title="为啥用数组模拟，不用结构体？"></a>为啥用数组模拟，不用结构体？</h3><p>new操作在算法题中速度偏慢，所以笔试用数组模拟链表。</p><h3 id="链表的作用"><a href="#链表的作用" class="headerlink" title="链表的作用"></a>链表的作用</h3><p>单链表在用邻接表存储图和树时十分有用。双链表可用于优化某些问题。</p><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><p>首先来看单链表，单链表属性主要有：<br>head表示头节点，e[N]存储链表的值;ne[N]存储链表下一个节点;idx表示当前的结点（处理第k个插入的数的需求）<br>单链表的操作有：init初始化、头插、插入（插到下标为k的点后）、删除（将下标为k后面的点删除）<br>注意：idx从0开始，所以add要k-1<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> head, e[N],ne[N],idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_head</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//头插入三连</span></span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    head = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = ne[k];</span><br><span class="line">    ne[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> k,x;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;H&#x27;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add_to_head</span>(x);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( op == <span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="comment">//删除需要特判是否为头节点</span></span><br><span class="line">            <span class="keyword">if</span>(!k) head = ne[head];</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">remove</span>(k<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(k<span class="number">-1</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head;i!=<span class="number">-1</span>;i=ne[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-数组模拟双链表"><a href="#2-数组模拟双链表" class="headerlink" title="2. 数组模拟双链表"></a>2. 数组模拟双链表</h2><h3 id="双链表与单链表的区别"><a href="#双链表与单链表的区别" class="headerlink" title="双链表与单链表的区别"></a>双链表与单链表的区别</h3><p>前面单链表用ne[N]记录下一个位置，这里需要l[N]和r[N]记录左右的位置。</p><h3 id="具体操作-1"><a href="#具体操作-1" class="headerlink" title="具体操作"></a>具体操作</h3><p>初始化：0表示左端点，1表示右端点。初始状态下r[0] = 1; l[1] = 0;<br>双链表支持5种操作：<br>最左边插入、最右边插入、将第k个插入的数删除、在第k个插入的数左侧插入，在第k个插入的数右侧插入。<br><strong>在节点a的右边插入一个数</strong>：idx左边指向a，右边指向r[a];通过a访问到r[a]，让r[a]左边指向idx，a的右边指向idx，并自增。<br><strong>删除元素</strong>：l[a]指向r[a],r[a]指向l[a];<br>注意：默认实现右插入，如何实现左插入？add(l[a],x);<br>最后：注意<strong>下标问题</strong>，初始化idx是从2开始的！<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> e[N],l[N],r[N],idx;</span><br><span class="line"><span class="comment">//在节点a的右边插入一个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = a , r[idx] = r[a];</span><br><span class="line">    l[r[a]] = idx, r[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    r[l[a]] = r[a];</span><br><span class="line">    l[r[a]] = l[a];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    r[<span class="number">0</span>]  = <span class="number">1</span>;</span><br><span class="line">    l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//询问</span></span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        string op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="type">int</span> k,x;</span><br><span class="line">        <span class="keyword">if</span>( op == <span class="string">&quot;L&quot;</span> )&#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">insert</span>(<span class="number">0</span>,x); <span class="comment">// 左端插入</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( op == <span class="string">&quot;R&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">insert</span>(l[<span class="number">1</span>],x);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ( op == <span class="string">&quot;D&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="built_in">remove</span>(k+<span class="number">1</span>);<span class="comment">//下标从2开始</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( op == <span class="string">&quot;IL&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">insert</span>(l[k+<span class="number">1</span>],x);<span class="comment">//还是注意下标从2开始</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">insert</span>(k+<span class="number">1</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=r[<span class="number">0</span>];i!=<span class="number">1</span>;i=r[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,e[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-模拟栈"><a href="#3-模拟栈" class="headerlink" title="3. 模拟栈"></a>3. 模拟栈</h2><p>栈：stk[N]  tt：栈顶<br>操作：insert、push、empty、top<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> stk[N],tt;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        string op;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>( op == <span class="string">&quot;push&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt;x;</span><br><span class="line">            stk[++tt] = x;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( op == <span class="string">&quot;pop&quot;</span>) tt--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;empty&quot;</span>) cout &lt;&lt; (tt? <span class="string">&quot;NO&quot;</span> :<span class="string">&quot;YES&quot;</span>) &lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; stk[tt] &lt;&lt;endl; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-模拟队列"><a href="#4-模拟队列" class="headerlink" title="4. 模拟队列"></a>4. 模拟队列</h2><p>队列：q[N]  hh: head  tt: rear<br>初始化: hh = 0   tt = -1<br>操作：insert pop empty getHead<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> q[N],hh,tt=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        string op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="keyword">if</span>( op == <span class="string">&quot;push&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            q[++tt] = x;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( op ==<span class="string">&quot;op&quot;</span>)&#123;</span><br><span class="line">            hh++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( op == <span class="string">&quot;empty&quot;</span>)&#123;</span><br><span class="line">            cout &lt;&lt; (hh&lt;=tt ? <span class="string">&quot;NO&quot;</span> : <span class="string">&quot;YES&quot;</span>) &lt;&lt; endl;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,q[hh]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="提升：单调栈【求离某数最近的且最小元素】"><a href="#提升：单调栈【求离某数最近的且最小元素】" class="headerlink" title="提升：单调栈【求离某数最近的且最小元素】"></a>提升：单调栈【求离某数最近的且最小元素】</h2><h3 id="模型引入"><a href="#模型引入" class="headerlink" title="模型引入"></a>模型引入</h3><p>例题：给一个序列，每一个数左边且离最近的且最小的数字在哪?<br>例如： 3 4 2 7 5  答案就是： -1 3 -1 2 2</p><h3 id="首先考虑暴力解法"><a href="#首先考虑暴力解法" class="headerlink" title="首先考虑暴力解法"></a>首先考虑暴力解法</h3><p>i从0到n  j从n-1到0  找a[j] &lt; a[i] break;</p><h3 id="寻找性质进行优化"><a href="#寻找性质进行优化" class="headerlink" title="寻找性质进行优化"></a>寻找性质进行优化</h3><p><img src="https://s2.loli.net/2023/01/07/6ueqtVrUY7bh3fy.gif" alt="演示单调栈" title="单调栈"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> stk[N],tt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>，&amp;x);</span><br><span class="line">        <span class="keyword">while</span>(tt &amp;&amp; stk[tt]&gt;=x) tt--;</span><br><span class="line">        <span class="keyword">if</span>(!tt) <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,stk[tt]);</span><br><span class="line">        stk[++tt] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="提升：单调队列【滑动窗口】"><a href="#提升：单调队列【滑动窗口】" class="headerlink" title="提升：单调队列【滑动窗口】"></a>提升：单调队列【滑动窗口】</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在一个大小为k的滑动窗口中，求出最大值和最小值</p><h3 id="第一步：考虑普通队列如何做？"><a href="#第一步：考虑普通队列如何做？" class="headerlink" title="第一步：考虑普通队列如何做？"></a>第一步：考虑普通队列如何做？</h3><p>对序列进行扫描，每次完成队列的入队和出队操作，大致需要进行n次。<br>对于每一次，如何求最值？—&gt;序列内部扫描一遍，需要扫描k次。<br>故时间复杂度为O(nk)</p><h3 id="第二步：思考利用性质优化—-gt-优先队列"><a href="#第二步：思考利用性质优化—-gt-优先队列" class="headerlink" title="第二步：思考利用性质优化—&gt;优先队列"></a>第二步：思考利用性质优化—&gt;优先队列</h3><ol><li>将普通队列的冗余元素删掉—&gt;队列具有单调性</li><li>可以用O(1)时间从队列或者队尾求出最值。所以时间优化为O(n)。<h4 id="以最小值为例，k-3为例子："><a href="#以最小值为例，k-3为例子：" class="headerlink" title="以最小值为例，k+3为例子："></a>以最小值为例，k+3为例子：</h4></li><li>如果队伍后面的数字大于新加入的数字new，就没意义。</li><li>把所以增的数字都去掉，</li><li>如果要求最小值，最后队列就是单调递增，只需要取队头即可。<h4 id="演示了一遍就通透很多，直接说有点难说明白"><a href="#演示了一遍就通透很多，直接说有点难说明白" class="headerlink" title="演示了一遍就通透很多，直接说有点难说明白"></a>演示了一遍就通透很多，直接说有点难说明白</h4>直接上代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单调队列--滑动窗口</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> a[N],q[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>,tt = <span class="number">-1</span>;<span class="comment">//模拟队列</span></span><br><span class="line">    <span class="comment">//首先求最小值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//判断是否在窗口内</span></span><br><span class="line">        <span class="keyword">if</span>(hh&lt;=tt &amp;&amp; q[hh] &lt; i-k+<span class="number">1</span>) hh++;</span><br><span class="line">        <span class="comment">//如果最新值小于队尾，不满足单调递增</span></span><br><span class="line">        <span class="keyword">while</span>(hh&lt;=tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--;</span><br><span class="line">        <span class="comment">//入队</span></span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="comment">//最小值：队头元素</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;=k<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//最大值：根据对称性即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//判断是否在窗口内</span></span><br><span class="line">        <span class="keyword">if</span>(hh&lt;=tt &amp;&amp; q[hh] &lt; i-k+<span class="number">1</span>) hh++;</span><br><span class="line">        <span class="comment">//如果最新值小于队尾，不满足单调递增</span></span><br><span class="line">        <span class="keyword">while</span>(hh&lt;=tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--;</span><br><span class="line">        <span class="comment">//入队</span></span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="comment">//最小值：队头元素</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;=k<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础算法-前缀和、差分、位运算、离散化、区间合并</title>
      <link href="/2023/01/01/230101%E7%AE%97%E6%B3%951_3/"/>
      <url>/2023/01/01/230101%E7%AE%97%E6%B3%951_3/</url>
      
        <content type="html"><![CDATA[<h1 id="算法基础：前缀和-差分"><a href="#算法基础：前缀和-差分" class="headerlink" title="算法基础：前缀和+差分"></a>算法基础：前缀和+差分</h1><h2 id="1-前缀和算法"><a href="#1-前缀和算法" class="headerlink" title="1. 前缀和算法"></a>1. 前缀和算法</h2><h3 id="一维前缀和；快速求原数组一段的和"><a href="#一维前缀和；快速求原数组一段的和" class="headerlink" title="一维前缀和；快速求原数组一段的和"></a>一维前缀和；快速求原数组一段的和</h3><p>如何快速初始化前缀和数列？s[i] = s[i-1] + a[i];<br>如何快速求原数组一段的和？对于区间[L,R]:S[r] - S[L-1]; 让S[0]=0<br>代码非常简单：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="comment">//前缀和下标都是从1开始的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="comment">//初始化前缀和数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) s[i] = s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="二维前缀和：快速求小矩形的面积（容斥原理思想）"><a href="#二维前缀和：快速求小矩形的面积（容斥原理思想）" class="headerlink" title="二维前缀和：快速求小矩形的面积（容斥原理思想）"></a>二维前缀和：快速求小矩形的面积（容斥原理思想）</h3><p>如何快速初始化前缀和数列？ s[i,j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1]  + a[i][j];<br>如何快速球以x1y1左上角和x2y2右下角的矩形和： S = S[x2,y2] - S[x2,y1-1] - S[x1-1,y2] + S[x1-1,y1-1]<br>提示：虽然快排在蓝桥杯用不到，但是以后的笔试面试中，面试官可能会让手写快排。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> a[N][N],s[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="type">int</span> a;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">            <span class="comment">//直接边读入边初始化前缀和数组</span></span><br><span class="line">            s[i][j] = s[i<span class="number">-1</span>][j] + s[i][j<span class="number">-1</span>] - s[i<span class="number">-1</span>][j<span class="number">-1</span>] + a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[x2][y2] - s[x2][y1<span class="number">-1</span>] - s[x1][y2<span class="number">-1</span>] + s[x1<span class="number">-1</span>][y1<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-差分算法—前缀和算法的逆运算"><a href="#2-差分算法—前缀和算法的逆运算" class="headerlink" title="2. 差分算法—前缀和算法的逆运算"></a>2. 差分算法—前缀和算法的逆运算</h2><p>作用：对于数组中[l,r]之间的元素，快速让每个元素都加上某个常数c。<br>原理：假想当前数组为前缀和数组，构造出原数组b[n],那么，要让a[l]到a[r]之间的数字都加上c，只需要让b[l]+c;并且让b[r+1]减去c。</p><h3 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>  N = <span class="number">100000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    b[l]+=c;</span><br><span class="line">    b[r+<span class="number">1</span>]-=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="comment">//将初始化当作是在i和i区间插入数字即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">insert</span>(i,i,a[i]);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> l,r,c;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r &gt;&gt; c;</span><br><span class="line">        <span class="built_in">insert</span>(l,r,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) b[i]+=b[i<span class="number">-1</span>];<span class="comment">//递推重新求和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维差分—差分矩阵"><a href="#二维差分—差分矩阵" class="headerlink" title="二维差分—差分矩阵"></a>二维差分—差分矩阵</h3><p>对b[x1][y1]+=c;b[x2+1][y1]-=c;b[x1][y2-1]-=c;b[x2+1][y2+1]+=c<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> a[N][N],b[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="comment">//差分核心</span></span><br><span class="line">    b[x1][y1]+=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y1]-=c;</span><br><span class="line">    b[x1][y2+<span class="number">1</span>]-=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y2+<span class="number">1</span>]+=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">insert</span>(i,j,i,j,a[i][j]);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;c);</span><br><span class="line">        <span class="built_in">insert</span>(x1,y1,x2,y2,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二维前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            b[i][j] = b[i<span class="number">-1</span>][j] + b[i][j<span class="number">-1</span>] - b[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i][j]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-位运算"><a href="#3-位运算" class="headerlink" title="3. 位运算"></a>3. 位运算</h2><h3 id="n的二进制表示中第k位是多少"><a href="#n的二进制表示中第k位是多少" class="headerlink" title="n的二进制表示中第k位是多少"></a>n的二进制表示中第k位是多少</h3><p>步骤：首先把第k位移动到最后一位，其次看最后一位是多少。</p><h3 id="【非常重要】lowbit运算"><a href="#【非常重要】lowbit运算" class="headerlink" title="【非常重要】lowbit运算"></a>【非常重要】lowbit运算</h3><p>功能：返回x的最后一位1开头的二进制数<br>例子：x = 101000  lowbit(x) = 1000<br>实现：x &amp; (-x)<br>作用：求1的个数—每次可以减一个1<br><strong>实例代码：求二进制中1的个数</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x) x-=<span class="built_in">lowbit</span>(x),res++;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-离散化"><a href="#4-离散化" class="headerlink" title="4. 离散化"></a>4. 离散化</h2><p>概念：将值域大个数小的数字映射到从0开始的自然数。<br>问题；</p><ol><li>a[]中有重复元素，必须去重操作。</li><li>如何算出离散化后的值？<br>思路：</li></ol><ul><li>unique函数可以去重并返回尾端点</li><li>可以二分查找某个数<br><strong>示例题目：在一个序列中给某位置上的数加上c后求某个区间和</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据范围：数据下标从-1e9到1e9，加上的数范围是1e5</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;<span class="comment">// 存放左右区间</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>; <span class="comment">// 离散后的数据范围</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],s[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;alls;    <span class="comment">//存放需要离散的数</span></span><br><span class="line">vector&lt;PII&gt;add,query;   <span class="comment">//存放的是需要进行添加和询问操作的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;    <span class="comment">// 二分查找</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid =  l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(alls[mid]&gt;=x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l  = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 注意：排完序下标就是映射的值</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;  <span class="comment">//n个操作，m个询问</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,c;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        add.<span class="built_in">push_back</span>(&#123;x,c&#125;);<span class="comment">//差分操作</span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(x);<span class="comment">//需要映射的数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        query.<span class="built_in">push_back</span>(&#123;l,r&#125;);<span class="comment">//虚伪呢</span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(l);<span class="comment">//需要映射的数字</span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去重操作：先排序后去重。</span></span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>());</span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>()),alls.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//添加操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item : add)&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">find</span>(item.first); <span class="comment">// 查找映射后的下标</span></span><br><span class="line">        a[x] += item.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理前缀和数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">1</span>;i&lt;=alls.<span class="built_in">size</span>();i++) s[i] = s[i<span class="number">-1</span>] + a[i];</span><br><span class="line">    <span class="comment">// 处理询问：一维前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item : query)&#123;</span><br><span class="line">        <span class="type">int</span>  l = <span class="built_in">find</span>(item.first);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">find</span>(item.second);</span><br><span class="line">        cout &lt;&lt; s[r] - s[l<span class="number">-1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-区间合并：贪心算法"><a href="#5-区间合并：贪心算法" class="headerlink" title="5. 区间合并：贪心算法"></a>5. 区间合并：贪心算法</h2>用去区间左端点进行排序。<br>维护的区间分成三种情况：子集、改变end、完全无交集。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;isotream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt;&amp;segs)</span></span>&#123;</span><br><span class="line">    vector&lt;PII&gt;res;</span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(),segs.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed =<span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> seg : segs)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ed &lt; seg.first)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st!=<span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st,ed&#125;);</span><br><span class="line">            st = seg.first;</span><br><span class="line">            ed = seg.sencond;</span><br><span class="line">        &#125;<span class="keyword">else</span> ed = <span class="built_in">max</span>(ed,seg.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(st!=<span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st,ed&#125;);</span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;PII&gt;segs;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> l ,r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        segs.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">merge</span>(segs);</span><br><span class="line">    cout &lt;&lt; segs.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-双指针算法求最长连续不重复子序列"><a href="#6-双指针算法求最长连续不重复子序列" class="headerlink" title="6. 双指针算法求最长连续不重复子序列"></a>6. 双指针算法求最长连续不重复子序列</h2>给定长度为n有序序列，求出最长的不包含重复的数的连续区间长度。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N  = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N],s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        s[a[i]]++;</span><br><span class="line">        <span class="keyword">while</span>(s[a[j]] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            s[a[j]]--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res,i-j+<span class="number">1</span>);<span class="comment">//循环结束i和j之间都没有重复元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt;  res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer第二章(P37-P51)</title>
      <link href="/2022/12/23/221223C++Primer/"/>
      <url>/2022/12/23/221223C++Primer/</url>
      
        <content type="html"><![CDATA[<h1 id="C-Primer第二章笔记-P37-P51"><a href="#C-Primer第二章笔记-P37-P51" class="headerlink" title="C++ Primer第二章笔记(P37-P51)"></a>C++ Primer第二章笔记(P37-P51)</h1><p>C++ Primer 每一页需要理解的时间都蛮长的emmm…<br>那又如何？CS学习可不能浅尝辄止，别妄想网上随便找个视频就能学明白一门技术。</p><h2 id="1-知识索引"><a href="#1-知识索引" class="headerlink" title="1. 知识索引"></a>1. 知识索引</h2><blockquote><p>指向指针的引用<br>const那些事1</p><h2 id="2-感慨：第一次静心翻开这本书"><a href="#2-感慨：第一次静心翻开这本书" class="headerlink" title="2. 感慨：第一次静心翻开这本书"></a>2. 感慨：第一次静心翻开这本书</h2></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础算法--高精度运算</title>
      <link href="/2022/12/18/221218%E7%AE%97%E6%B3%951_2/"/>
      <url>/2022/12/18/221218%E7%AE%97%E6%B3%951_2/</url>
      
        <content type="html"><![CDATA[<h1 id="算法基础：高精度运算"><a href="#算法基础：高精度运算" class="headerlink" title="算法基础：高精度运算"></a>算法基础：高精度运算</h1><p>开头先感慨一下：正如斯坦福CS106L老师讲的，用前沿的C++语言确实比用老套的C美丽得多。<br>在高精度这件事情上，C需要处理的细节十分繁杂，而C++可以让代码更加优美简洁。</p><h2 id="算法—高精度运算"><a href="#算法—高精度运算" class="headerlink" title="算法—高精度运算"></a>算法—高精度运算</h2><p>听说高精度运算这类题目是C++同学独有哈哈，JAVA和python都不需要掌握。（强颜欢笑.jpg）<br>分类</p><ul><li>高精度加法 A + B</li><li>高精度减法 A - B （默认A &gt; B，反之只需特判。如出现负数，分类讨论加减法）</li><li>高精度乘法 A * a （一个大整数除以一个正常数）</li><li>高精度除法 A / a （高精度乘法和除法不会出现大数，概率小）<br><strong>高精度加法</strong><br>加法就是逐位相加，有进位。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">//加法函数</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;A,vector&lt;<span class="type">int</span>&gt;&amp;B)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;C;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>() || i&lt;B.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; A.<span class="built_in">size</span>()) t+=A[i];</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t+=B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t%<span class="number">10</span>);</span><br><span class="line">        t/=<span class="number">10</span>;</span><br><span class="line">        <span class="comment">//一气呵成</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t) C.<span class="built_in">push_back</span>(<span class="number">1</span>);<span class="comment">//最后记得特判是否存在进位</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;A,B;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b; <span class="comment">// a = &quot;123456&quot;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);<span class="comment">//翻转</span></span><br><span class="line">    <span class="comment">//A = [6,5,4,3,2,1]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=b.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">auto</span> C  = <span class="built_in">add</span>(A,B);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>高精度减法</strong><br>主要在于结位。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">//  判断是否有 A&gt;=B</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;A,vector&lt;<span class="type">int</span>&gt;&amp;B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.<span class="built_in">size</span>()!=B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">            <span class="keyword">if</span>(A[i]!=B[i])</span><br><span class="line">                <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 相等也满足条件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;A,vector&lt;<span class="type">int</span>&gt;&amp;B)</span></span>&#123;</span><br><span class="line">    <span class="comment">//进行减法的实现</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;C;</span><br><span class="line">    <span class="comment">//  这里A的位数一定大于等于B的位数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,t=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;B.<span class="built_in">size</span>()) t-=B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t+<span class="number">10</span>)%<span class="number">10</span>); <span class="comment">// 这里可以将两种情况统一来写</span></span><br><span class="line">        <span class="comment">// 这里每一次减法的结果分为：大于等于0 为自己 小于0 借位</span></span><br><span class="line">        <span class="keyword">if</span>(t&lt;<span class="number">0</span>) t =<span class="number">1</span>; <span class="comment">//借位</span></span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//除掉前导0</span></span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>()==<span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;A,B;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b; <span class="comment">// a = &quot;123456&quot;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="comment">//A = [6,5,4,3,2,1]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=b.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(A,B))&#123; <span class="comment">// 是否A&gt;=B</span></span><br><span class="line">        <span class="keyword">auto</span> C = <span class="built_in">sub</span>(A,B);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]); </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> C = <span class="built_in">sub</span>(B,A);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>高精度乘法</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;A,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>() || t;i++)&#123; <span class="comment">//将最后的进位处理合在一起</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;A.<span class="built_in">size</span>()) t += A[i]*b; </span><br><span class="line">        C.<span class="built_in">push_back</span>(t%<span class="number">10</span>);<span class="comment">//当前位数</span></span><br><span class="line">        t/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>); <span class="comment">// 记得转化为整数</span></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">mul</span>(A,b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>高精度除法</strong><br>除法是从最高位开始运算的，本来应该正着存储。<br>但是题目一般不只考察除法，所以倒叙存储。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;A,<span class="type">int</span> b,<span class="type">int</span> &amp;r)</span></span>&#123;</span><br><span class="line">    <span class="comment">//A / b  商C 余r</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 6 5 4 3 2 1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        r = r* <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r/b);</span><br><span class="line">        r%=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1 2 3 4 5 6  但是输出的时候仍旧是反转输出，所以需要reverse</span></span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(),C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//去除前导0</span></span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="type">int</span> r; <span class="comment">// 余数是r</span></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">div</span>(A,b,r);<span class="comment">// A除以b，余数是r，商C</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础算法-快排、归并、二分</title>
      <link href="/2022/12/18/221218%E7%AE%97%E6%B3%951_1/"/>
      <url>/2022/12/18/221218%E7%AE%97%E6%B3%951_1/</url>
      
        <content type="html"><![CDATA[<h1 id="算法基础：快排、归并排序、二分"><a href="#算法基础：快排、归并排序、二分" class="headerlink" title="算法基础：快排、归并排序、二分"></a>算法基础：快排、归并排序、二分</h1><h2 id="1-快排模板"><a href="#1-快排模板" class="headerlink" title="1. 快排模板"></a>1. 快排模板</h2><p>快排的核心思想:分治。<br>步骤：</p><ol><li>确定分界点。</li><li>重新调整区间。—双指针法。</li><li>递归处理左右两端。<br><strong>快排由于边界问题，建议直接背诵模板</strong><br>提示：虽然快排在蓝桥杯用不到，但是以后的笔试面试中，面试官可能会让手写快排。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;=r ) <span class="keyword">return</span> ; <span class="comment">//边界判断</span></span><br><span class="line">    <span class="comment">//确定分界点</span></span><br><span class="line">    <span class="type">int</span> x = q[l + r &gt;&gt; <span class="number">1</span>], i = l<span class="number">-1</span> , j = r+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//双指针调整区间</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j )&#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) <span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,l,j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,j+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-快速查找算法"><a href="#2-快速查找算法" class="headerlink" title="2. 快速查找算法"></a>2. 快速查找算法</h2>在快速排序基础上返回第k个数。<br>快排分区间的时候，如果k小于左边的长度，递归左边。否则递归右边。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> l , <span class="type">int</span> r, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> q[l]; <span class="comment">//返回查找的值</span></span><br><span class="line">    <span class="type">int</span> x = q[l] , i = l<span class="number">-1</span> , r = r+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j ) <span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//到这里都与快排基本一样</span></span><br><span class="line">    <span class="type">int</span> sl = j - l +<span class="number">1</span>; <span class="comment">//表示左边区间的长度</span></span><br><span class="line">    <span class="keyword">if</span>(k &lt;= sl) <span class="keyword">return</span> <span class="built_in">quick_sort</span>(l,j,k);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">quick_sort</span>(j+<span class="number">1</span>,r,k - sl);<span class="comment">//注意这里是k-sl</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-归并排序"><a href="#3-归并排序" class="headerlink" title="3. 归并排序"></a>3. 归并排序</h2>快排的思路是先调整后递归。<br>归并的思路是先递归排序后合并，合并同样用双指针算法。<br><strong>归并排序时间复杂度严格为NlogN</strong><br><strong>相比之下，快排的时间复杂度期望是NlogN</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l , <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;=r ) <span class="keyword">return</span>;<span class="comment">//递归排序都需要边界</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q,l,mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="comment">//双指针合并</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;=mid &amp;&amp; j&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i] &lt;=q[j]) tmp[k++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k++] = q[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一轮后剩下的push到答案</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) tmp[k++] = q[j++];</span><br><span class="line">    <span class="comment">//重新把tmp数组拷到q数组内</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l,j=<span class="number">0</span>;i&lt;=r;i++,j++)</span><br><span class="line">        q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-整数二分和浮点数二分"><a href="#4-整数二分和浮点数二分" class="headerlink" title="4. 整数二分和浮点数二分"></a>4. 整数二分和浮点数二分</h2>二分的本质：存在某个性质使得左边满足右边不满足。<br>由于整数二分模板有两种类型，具体来实践来看先写check看如何更新，再找答案。<br><strong>浮点数二分：只要区间划分到足够小就好了，注意一下精度的问题，判断条件比题目多两位精度</strong><br>整数二分：以《数的范围》为例。<br>给定一个有序序列，发N个询问，对于每个询问求某数字在序列中起始位置和终止位置。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="comment">//开始二分--找左端点</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[mid] &gt;=x ) r= mid;</span><br><span class="line">            <span class="keyword">else</span> l  = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到左端点先特判是否找到</span></span><br><span class="line">        <span class="keyword">if</span>(a[l] != x) cout &lt;&lt;<span class="string">&quot;-1 -1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; l &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            l = <span class="number">0</span>,r= n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">                <span class="type">int</span> mid = l + r +<span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[mid]&lt;=x) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>浮点数二分<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="type">double</span> l =<span class="number">-10000</span>, r=<span class="number">10000</span>;</span><br><span class="line"><span class="keyword">while</span>(r - l &gt;<span class="number">1e-8</span>)&#123; <span class="comment">// 也可以不管啥直接迭代100次，除以100次。</span></span><br><span class="line">    <span class="type">double</span> mid = (l + r) /<span class="number">2</span>; <span class="comment">// 浮点数不能用位运算</span></span><br><span class="line">    <span class="keyword">if</span>(mid*mid*mid&lt;=x) l = mid;</span><br><span class="line">    <span class="keyword">else</span> r=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.6lf&quot;</span>,l);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stanford CS106L 笔记-lecture01</title>
      <link href="/2022/12/18/221218CS106L_Stanford/"/>
      <url>/2022/12/18/221218CS106L_Stanford/</url>
      
        <content type="html"><![CDATA[<h1 id="Stream-I"><a href="#Stream-I" class="headerlink" title="Stream I"></a>Stream I</h1><aside>🥊 2022/12/18 14:14</aside><h2 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h2><ul><li>ostringstream</li><li>istringstream</li><li>bit state</li></ul><p>EX：write a function stringToInterger</p><h2 id="stringstream"><a href="#stringstream" class="headerlink" title="stringstream"></a>stringstream</h2><h3 id="ostringstream"><a href="#ostringstream" class="headerlink" title="ostringstream"></a>ostringstream</h3><p>it is not connected to any external source. only type conversion.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span> <span class="comment">// for stringstream</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">ostringstream <span class="title">oss</span><span class="params">(<span class="string">&quot;Ito En Green Tea&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// ostringstream oss(&quot;Ito En Green Tea &quot;,ostringstream::ate);</span></span><br><span class="line">    cout &lt;&lt; oss.<span class="built_in">str</span>() &lt;&lt; endl; </span><br><span class="line">    oss &lt;&lt; <span class="number">16.9</span> &lt;&lt; <span class="string">&quot; Ounce &quot;</span>;</span><br><span class="line">    cout &lt;&lt; oss.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;(Pack of &quot;</span> &lt;&lt; <span class="number">12</span> &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    cout &lt;&lt; oss.<span class="built_in">str</span>() &lt;&lt; endl; <span class="comment">// still overwrite</span></span><br><span class="line"></span><br><span class="line">    <span class="function">istringstream <span class="title">iss</span><span class="params">(oss.str())</span></span>;</span><br><span class="line">    <span class="type">double</span> account;</span><br><span class="line">    string unit;</span><br><span class="line">    iss &gt;&gt; account &gt;&gt; unit;</span><br><span class="line">    cout &lt;&lt; account &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; unit &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;half of the acoount is &quot;</span> &lt;&lt; account/<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/6efd1fdb-47e5-4af2-9bbd-b81223945bd4/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221218%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20221218T085642Z&amp;X-Amz-Expires=86400&amp;X-Amz-Signature=355b26e207a56db547d3d9b0262a67f246d75f4d7cdd1f2a76a60920fc129cb3&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%3D%22Untitled.png%22&amp;x-id=GetObject" alt="Untitled"></p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/6d71654d-ceb6-4a52-8c39-86a62cd97dd7/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221218%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20221218T085711Z&amp;X-Amz-Expires=86400&amp;X-Amz-Signature=b99f3f9e75da238b19d5703849983faf034722976f5dd792dac1390ce33999a8&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%3D%22Untitled.png%22&amp;x-id=GetObject" alt="Untitled"></p><p>The position started in the front, so we are <strong>overwriting</strong> the buffer.</p><p>if you use ostringstream(”something”,ostringstream::ate); then it starts at end.</p><h3 id="istringstream"><a href="#istringstream" class="headerlink" title="istringstream"></a>istringstream</h3><p>input streams read up to the next whitespace</p><p>also skips any leading whitespace</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">ostringstream <span class="title">oss</span><span class="params">(<span class="string">&quot;Ito En Green Tea &quot;</span>)</span></span>;</span><br><span class="line">    oss &lt;&lt; <span class="number">16.9</span>;</span><br><span class="line">    fpos pos = oss.<span class="built_in">tellp</span>() + <span class="built_in">streamoff</span>(<span class="number">3</span>);</span><br><span class="line">    oss.<span class="built_in">seekp</span>(pos);</span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;black&quot;</span> ;</span><br><span class="line">    cout &lt;&lt; oss.<span class="built_in">str</span>() &lt;&lt; endl;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/1c96068f-5463-4a3e-8864-5495d7610567/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221218%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20221218T085724Z&amp;X-Amz-Expires=86400&amp;X-Amz-Signature=63e1d14b766f27ec60a9ff8925917fe4dc07ea462bf20099de6424b3d7654602&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%3D%22Untitled.png%22&amp;x-id=GetObject" alt="Untitled"></p><h3 id="bit-state"><a href="#bit-state" class="headerlink" title="bit state"></a>bit state</h3><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/8551b75d-aa15-46f1-bcb1-bceb9b2007fe/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221218%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20221218T085740Z&amp;X-Amz-Expires=86400&amp;X-Amz-Signature=13d8a299b4c87156acc3a70fa3809621e79f5c75c9cfb0c1d4ea9897b7614133&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%3D%22Untitled.png%22&amp;x-id=GetObject" alt="Untitled"></p><p>good and bad  good and fail are not opposites</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">stringToInteger</span><span class="params">(<span class="type">const</span> string&amp; str)</span></span>&#123;</span><br><span class="line">    <span class="function">istringstream <span class="title">iss</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    iss &gt;&gt;  value;</span><br><span class="line">    <span class="keyword">if</span>(iss.<span class="built_in">fail</span>() || !iss.<span class="built_in">eof</span>()) <span class="keyword">throw</span> <span class="built_in">domain_error</span>(<span class="string">&quot;StringInteger ...&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pritnStateBits</span><span class="params">(istream&amp; s)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;State bits : &quot;</span>;</span><br><span class="line">    cout &lt;&lt; (s.<span class="built_in">good</span>() ? <span class="string">&quot;G&quot;</span> : <span class="string">&quot;-&quot;</span>);</span><br><span class="line">    cout &lt;&lt; (s.<span class="built_in">fail</span>() ? <span class="string">&quot;F&quot;</span> : <span class="string">&quot;-&quot;</span>);</span><br><span class="line">    cout &lt;&lt; (s.<span class="built_in">eof</span>() ? <span class="string">&quot;E&quot;</span> : <span class="string">&quot;-&quot;</span>);</span><br><span class="line">    cout &lt;&lt; (s.<span class="built_in">bad</span>() ? <span class="string">&quot;B&quot;</span> : <span class="string">&quot;-&quot;</span>);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;usage : arg1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> val = <span class="built_in">stringToInteger</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You enter is &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Half of that is &quot;</span> &lt;&lt; val/<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer第二章(P37-P51)</title>
      <link href="/2022/12/18/221218C++Primer/"/>
      <url>/2022/12/18/221218C++Primer/</url>
      
        <content type="html"><![CDATA[<h1 id="C-Primer第二章笔记-P37-P51"><a href="#C-Primer第二章笔记-P37-P51" class="headerlink" title="C++ Primer第二章笔记(P37-P51)"></a>C++ Primer第二章笔记(P37-P51)</h1><h2 id="1-知识索引"><a href="#1-知识索引" class="headerlink" title="1. 知识索引"></a>1. 知识索引</h2><p>列表初始化   分离式编译   新的标识符命名规范<br>作用域操作符   复合类型—引用和指针的区分</p><h2 id="2-感慨：第一次静心翻开这本书"><a href="#2-感慨：第一次静心翻开这本书" class="headerlink" title="2. 感慨：第一次静心翻开这本书"></a>2. 感慨：第一次静心翻开这本书</h2><h3 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h3><p>《C++ Primer》在11月份左右买来，当时已经看完了黑马程序员C++的全部内容，于是在多抓鱼上订来这本C++领域的知名大部头，却一直没专门安排时间翻阅。<br>究其原因，其实是有更多想做的事情。比如在学完黑马程序员后的大部分时间，我的时间几乎都是用来探索算法的学习。从《啊哈，算法》入门到前往洛谷刷题被题目狂虐到上B站找零散的视频进行学习，算法的学习之路一直很陡峭，感觉也在走弯路，没有进步。后面又认识了《挑战程序设计竞赛》这本书，结果在DP章节也被卡住了。好在临近12月份找到了ACWing的y总，感叹总算能给自己的算法学习系统一下了，于是几乎一天所有时间都花在了算法上，甚至微积分都有点荒废了…</p><h3 id="泥泞"><a href="#泥泞" class="headerlink" title="泥泞"></a>泥泞</h3><p>学习计算机从来不能局限于学校，不能局限于现实，也就是说，要超越你当前的视野。只有向巨人看齐，才会机会成为巨人。<br>然而，说句实话，在我的周围绝大部分同学都深陷于学业的泥沼中，他们不过把学习计算机当成了另一场“考试”，因此我也没有找到与我兴致和志趣相同的好友相伴学习。他们想等待填鸭，而我，想着往更广阔的世界探索。</p><h3 id="自我救赎"><a href="#自我救赎" class="headerlink" title="自我救赎"></a>自我救赎</h3><p>如果在高考前不断憧憬的大学生活只留下了随波逐流，那这余生也就无所谓意义了。我的想法是：在人生的任何时期，都要批判性地逆着大流走。世界人口达到80亿，在80亿之中，独立的灵魂更加可贵。<br>我喜欢向互联网上已经就业的前辈和已经读研的前辈取经，在这个过程中，我确定了大学四年的核心规划：通过自学提高竞争力。<br>现在回想起来，11月到12月中旬的现在，我犯的最大错误就是焦虑和过度在意他人的想法。</p><h3 id="凌晨起意"><a href="#凌晨起意" class="headerlink" title="凌晨起意"></a>凌晨起意</h3><p>已经凌晨1点了，第一次静下心来认真读这本C++领域“圣经”般的大部头。的确收获良多！</p><h4 id="之前的学习路线总结下来就是："><a href="#之前的学习路线总结下来就是：" class="headerlink" title="之前的学习路线总结下来就是："></a>之前的学习路线总结下来就是：</h4><blockquote><p>黑马程序员的C++全套看完 + 做完配套的小项目 + 刷OJ题过程中对STL的熟练 = 了解了C++的基础</p><h4 id="未来的学习路线："><a href="#未来的学习路线：" class="headerlink" title="未来的学习路线："></a>未来的学习路线：</h4><p>先通过《C++Primer》深入理解这门语言。再继续往《Effetive C++》和《STL源码剖析》这两本书看。<br>课程方面，寒假打算学习<em>CS106L: Standard C++ Programming</em>，利用高质量的lab锻炼自己的编码能力。</p><h2 id="3-碎碎念最近的烦心事"><a href="#3-碎碎念最近的烦心事" class="headerlink" title="3. 碎碎念最近的烦心事"></a>3. 碎碎念最近的烦心事</h2><ul><li>好多事情想做，好多公开课想看，但是学校教授的无用课程一直在浪费我的时间，特别是数字逻辑。</li><li>微积分最近也懈怠了好久，写定积分的应用和微分方程被按在地上摩擦，哎……</li><li>最近一直熬夜，新冠又这么流行，对自己的健康很是担忧😂。加上最近一直做电脑前，眼睛也要保重呀</li></ul></blockquote><h2 id="4-最后"><a href="#4-最后" class="headerlink" title="4. 最后"></a>4. 最后</h2><p><strong>想要保研，就必须自行兼顾自学和课业。</strong><br><strong>物竞天择，适者生存。学会兼顾和平衡是成为强者道路上必不可少的。加油！奥里给！</strong></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>闲聊杂谈--我的hexo博客搭建过程</title>
      <link href="/2022/12/16/%E7%AC%AC%E5%85%AD%E7%AF%87/"/>
      <url>/2022/12/16/%E7%AC%AC%E5%85%AD%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="闲聊杂谈—我的hexo博客搭建过程"><a href="#闲聊杂谈—我的hexo博客搭建过程" class="headerlink" title="闲聊杂谈—我的hexo博客搭建过程"></a>闲聊杂谈—我的hexo博客搭建过程</h2><p>闲聊杂谈—我的hexo博客搭建过程</p><h2 id="我爱博客，我爱分享，我爱编程"><a href="#我爱博客，我爱分享，我爱编程" class="headerlink" title="我爱博客，我爱分享，我爱编程"></a>我爱博客，我爱分享，我爱编程</h2>]]></content>
      
      
      <categories>
          
          <category> 闲聊杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WEB前端学习</title>
      <link href="/2022/12/15/230104%E5%89%8D%E7%AB%AF/"/>
      <url>/2022/12/15/230104%E5%89%8D%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="WEB前端"><a href="#WEB前端" class="headerlink" title="WEB前端"></a>WEB前端</h2><p>WEB前端</p><h2 id="MIT-WEBLAB-我来啦"><a href="#MIT-WEBLAB-我来啦" class="headerlink" title="MIT WEBLAB 我来啦"></a>MIT WEBLAB 我来啦</h2>]]></content>
      
      
      <categories>
          
          <category> WEB前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础进度--OOP多态</title>
      <link href="/2022/12/15/230103java/"/>
      <url>/2022/12/15/230103java/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础—多态"><a href="#Java基础—多态" class="headerlink" title="Java基础—多态"></a>Java基础—多态</h1><h2 id="汇报学习进度：基础篇—OOP—多态"><a href="#汇报学习进度：基础篇—OOP—多态" class="headerlink" title="汇报学习进度：基础篇—OOP—多态"></a>汇报学习进度：基础篇—OOP—多态</h2><p>学习的目的就是为了让自己理解得更加深刻。<br>学习接触过的知识从来没有遗忘，只是烙在了脑中罢了。<br>我感觉自己之所以理解多态比较顺利，不仅是韩顺平老师讲得通透，更是自己之前学过C++面向对象并且经历过一些项目的捶打。想要了解一个专业的知识，就是要通过这种触类旁通 + 实践的方式，让对知识的理解更加深刻。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA后端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++项目--基于多态的职工管理系统</title>
      <link href="/2022/12/15/%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/12/15/%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="C-项目—基于多态的职工管理系统"><a href="#C-项目—基于多态的职工管理系统" class="headerlink" title="C++项目—基于多态的职工管理系统"></a>C++项目—基于多态的职工管理系统</h2><p>C++项目—基于多态的职工管理系统</p><h2 id="我爱C-，我爱学习，我爱编程"><a href="#我爱C-，我爱学习，我爱编程" class="headerlink" title="我爱C++，我爱学习，我爱编程"></a>我爱C++，我爱学习，我爱编程</h2>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法--线段树和树状数组</title>
      <link href="/2022/12/15/%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/12/15/%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="算法—线段树和树状数组"><a href="#算法—线段树和树状数组" class="headerlink" title="算法—线段树和树状数组"></a>算法—线段树和树状数组</h2><p>算法—线段树和树状数组</p><h2 id="我爱蓝桥杯"><a href="#我爱蓝桥杯" class="headerlink" title="我爱蓝桥杯"></a>我爱蓝桥杯</h2>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 测试文章</title>
      <link href="/2022/12/15/C++%E5%88%86%E7%B1%BB/"/>
      <url>/2022/12/15/C++%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="C-这是C-板块的测试文章"><a href="#C-这是C-板块的测试文章" class="headerlink" title="C++这是C++板块的测试文章"></a>C++这是C++板块的测试文章</h2><p>C++ Primer第二章笔记</p><h2 id="C-Primer第二章笔记"><a href="#C-Primer第二章笔记" class="headerlink" title="C++ Primer第二章笔记"></a>C++ Primer第二章笔记</h2>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
