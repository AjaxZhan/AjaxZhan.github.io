<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>动态规划DP(一)背包问题</title>
      <link href="/posts/68b5aee0.html"/>
      <url>/posts/68b5aee0.html</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划DP-一-背包问题"><a href="#动态规划DP-一-背包问题" class="headerlink" title="动态规划DP(一)-背包问题"></a>动态规划DP(一)-背包问题</h1><p>本篇介绍4个基础的背包问题以及其经典优化</p><ul><li>01背包问题</li><li>完全背包问题</li><li>多重背包问题</li><li>分组背包问题</li></ul><div class="tag link"><a class="link-card" title="所有代码已提交GitHub" href="https://github.com/AjaxZhan/algorithm_learning/tree/master/level_basic"><div class="left"><img src="https://github.com/fluidicon.png"/></div><div class="right"><p class="text">所有代码已提交GitHub</p><p class="url">https://github.com/AjaxZhan/algorithm_learning/tree/master/level_basic</p></div></a></div><h1 id="背包问题基本设问"><a href="#背包问题基本设问" class="headerlink" title="背包问题基本设问"></a>背包问题基本设问</h1><p>背包问题基本设问：N个物品，背包容量为V，每件物品分别是vi和价值wi，求总价值最大值。<br>01背包问题：每件物品最多只用一次。<br>完全背包问题：每件物品有无数个。<br>多重背包问题：每个物品只有xi个。<br>分组背包问题：每一组内最多只能选1个。</p><h1 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h1><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>动态规划问题一般从“状态表示”和“状态计算”两个方面来考虑。</p><h3 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h3><p>f[i,j]的集合表示：从前i个物品中选取容量不超过j的所有选法。<br>f[i,j]的属性表示：选法中能够使得价值最大值的数。</p><h3 id="状态计算"><a href="#状态计算" class="headerlink" title="状态计算"></a>状态计算</h3><p>状态计算实际上是一个集合划分的过程。<br>f[i,j]可以分成：不包含第i个物品 和 包含第i个物品 两个子集。<br>不包含第i个物品：从前i-1个物品中选，并且容量不超过j—&gt; f[i-1,j]<br>包含第i个物品：采用曲线救国的策略，等于不选 + 选 即 f[i-1,j-v[i]]+w[i]<br>综上，状态方程为：f[i,j] = max(f[i-1,j],f[i-1,j-v[i] + w[i]])</p><h2 id="一维优化"><a href="#一维优化" class="headerlink" title="一维优化"></a>一维优化</h2><p>所有背包问题优化都是基于代码做优化，与问题本身的分析无关。<br>由于f[i]只用到f[i-1]这一层，并且f[j]这一层j-v[i]&lt;=j,因此可以优化成一维。</p><blockquote><p>GitHub上的代码已经有详细的注释</p></blockquote><h1 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h1><h2 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="状态表示-1"><a href="#状态表示-1" class="headerlink" title="状态表示"></a>状态表示</h3><p>f[i,j]的集合表示：所有只考虑前i个物品，并且总体积&lt;=j的所有选法。<br>f[i,j]的属性表示：选法中能够使得价值最大值的数。</p><h3 id="状态计算-1"><a href="#状态计算-1" class="headerlink" title="状态计算"></a>状态计算</h3><p>按照第i个物品选多少个来分，可以为0,1,2,…k-1,k<br>如果选0个：f[i-1,j]<br>如果选k个：f[i-1,j-k<em>v[i]] + k</em>w[i]</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>对比:<br>f[i,j] = max(f[i-1,j],f[i-1,j-v]+w,f[i-1,j-2<em>v] + 2w,…)<br>f[i,j-v] = max(       f[i-1,j-v],  f[i-1,j-2</em>v] + w , …)<br>可以看出上下相差w<br>所以总结出：f[i,j] = max(f[i-1,j],f[i,j-v])<br>由此优化掉了k那一层循环，并且可以如同01背包的优化那样转成一维。</p><h1 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h1><h2 id="问题分析-2"><a href="#问题分析-2" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="状态表示-2"><a href="#状态表示-2" class="headerlink" title="状态表示"></a>状态表示</h3><p>f[i,j]的集合表示：所有只考虑前i个物品，并且总体积&lt;=j的所有选法。<br>f[i,j]的属性表示：选法中能够使得价值最大值的数。</p><h3 id="状态计算-2"><a href="#状态计算-2" class="headerlink" title="状态计算"></a>状态计算</h3><p>按照第i个物品选多少个来分，可以为0,1,2,…s-1,s<br>与完全背包问题类似：f[i,j] = max(f[i-1,j],f[i-1,j-k<em>v[i]] + k</em>w[i]) k从0到s[i]数据小能过</p><h2 id="优化1"><a href="#优化1" class="headerlink" title="优化1"></a>优化1</h2><p>二进制优化法，将k这层线性转换为log级别。<br>si可以拆成：1 2 4 8 16 … 2^k c (c&lt;2^k+1) 可以凑出0-s内的任何数，且每个数只被选1次。<br><em>证明方式莫名想到某年数学高考题的压轴填空……</em><br>从0-2^k可以凑出，0-2^k+1内的数字，加c可以凑出c到s之间的数字，由于c&lt;2^k+1因此成立可以凑出0-s内的数字。<br>这样就将问题转换为<strong>做logsi次01背包问题</strong>了。</p><h2 id="优化2：单调队列优化"><a href="#优化2：单调队列优化" class="headerlink" title="优化2：单调队列优化"></a>优化2：单调队列优化</h2><p>目前还不会emmm…</p><h1 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h1><h2 id="问题分析-3"><a href="#问题分析-3" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="状态表示-3"><a href="#状态表示-3" class="headerlink" title="状态表示"></a>状态表示</h3><p>f[i,j]的集合表示：所有只从前i组物品中选，并且总体积&lt;=j的所有选法。<br>f[i,j]的属性表示：选法中能够使得价值最大值的数。</p><h3 id="状态计算-3"><a href="#状态计算-3" class="headerlink" title="状态计算"></a>状态计算</h3><p>从某一组中选哪个？<br>f[i,j] = max(f[i-1,j],f[i-1,j-v[i,k]] + w[i,k])</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaSE--多线程</title>
      <link href="/posts/5ed32d67.html"/>
      <url>/posts/5ed32d67.html</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li>基本概念</li><li>线程的使用<ul><li>方式1：继承Thread类</li><li>方式2：实现Runnable接口</li></ul></li><li>线程的方法</li><li>线程的生命周期</li><li>Synchronized关键字</li><li>锁<ul><li>互斥锁</li><li>死锁</li></ul></li></ul><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul><li>程序：指令的集合。</li><li>进程：程序的一次执行过程，或者正在运行一个程序。进程是一个动态过程，有自己产生、存在、消亡的过程。</li><li>线程：线程<strong>由进程创建</strong>，是进程的一个实体。一个进程可以拥有多个线程。<ul><li>单线程：同一个时刻只允许执行一个线程。</li><li>多线程：同一个时刻，可以实现多个线程。</li></ul></li><li>并发和并行：<ul><li>并发：同一个时刻，多个任务交替执行。因为CPU执行速度很快，造成貌似同时的错觉。简单来说，就是单核CPU执行多任务。</li><li>并行：同一个时刻，多个任务同时执行。多核CPU可以实现并行。并行和并发可以同时存在。</li></ul></li></ul><h1 id="线程的基本使用"><a href="#线程的基本使用" class="headerlink" title="线程的基本使用"></a>线程的基本使用</h1><ul><li>线程的两种创建方式：<ul><li>继承Thread类，重写Run方法</li><li>实现Runnable接口，重写Run方法</li></ul></li><li>多线程机制：进程—&gt;开启main线程 —&gt;start 开启Thread0线程。<ul><li>主线程挂掉，子线程不一定结束。所有线程都结束就标志了进程结束。</li></ul></li></ul><h2 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h2><p>例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MAIN方法内：</span></span><br><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">cat.start(); <span class="comment">// 启动线程Thead0进程</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">60</span>;i++) sout(<span class="string">&quot;主线程&quot;</span> + i); <span class="comment">// 主线程不会诸塞，会继续执行，这个时候主线程和子线程和交替执行</span></span><br><span class="line"><span class="comment">//通过Thread类创建线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//重写Run方法，实现业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>为什么主函数调用的是run()不是start()？<ul><li>底层代码中，start()方法调用native的start0()，这个start0()才是真正实现多线程的地方。</li><li>start0()方法由JVM机调用，底层用C++/C实现，需要注意的是：执行start0后线程并不一定会立刻执行，<strong>只是将线程变成了可运行状态，具体执行时间由CPU调度</strong></li></ul></li></ul><h2 id="实现Runnable接口—静态代理模式"><a href="#实现Runnable接口—静态代理模式" class="headerlink" title="实现Runnable接口—静态代理模式"></a>实现Runnable接口—静态代理模式</h2><ul><li>需求：Java是单继承机制，某些情况下一个类已经继承父类，无法再次继承Thread类。</li><li>解决：继承Runnable接口实现Run</li></ul><p>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(dog); <span class="comment">// 这里将实现Runnable接口的Thread放入，用到了静态代理模式</span></span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Runnable的机制—静态代理模式"><a href="#Runnable的机制—静态代理模式" class="headerlink" title="Runnable的机制—静态代理模式"></a>Runnable的机制—静态代理模式</h3><ul><li>Thread类实现了Runnable接口，设置一个private的 Runnable接口属性。</li><li>在Thread的Run方法中，调用这个<strong>Runnable接口属性的run方法</strong>。</li><li>Thread提供构造器，初始化这个属性</li><li>这样在执行的时候，run()进行动态绑定，会执行你传入的类的run方法</li></ul><p>下面代码模拟静态代理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread_</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target!=<span class="literal">null</span>) target.run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Thread_</span><span class="params">(Runnable target)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        start0();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="线程终止—通知方式"><a href="#线程终止—通知方式" class="headerlink" title="线程终止—通知方式"></a>线程终止—通知方式</h2><p>当线程完成任务后会自动退出，可以通过使用在变量来控制run方法退出的方式停止线程。<br>一般思路是给线程就加一个属性loop，提供set方法，然后在主方法中调用setloop方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(loop)&#123;</span><br><span class="line">            sout(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoop</span><span class="params">(<span class="type">boolean</span> loop)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.loop = loop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程的七大状态"><a href="#线程的七大状态" class="headerlink" title="线程的七大状态"></a>线程的七大状态</h1><ul><li>New未启动</li><li>RUNNABLE运行中（Ready + Running）</li><li>BLOCKED阻塞</li><li>WAITING等待</li><li>TIMED_WATING超时等待</li><li><p>TERMINATED终止</p></li><li><p>用户线程：工作进程。当线程任务完成或用通知方式才结束。</p></li><li>守护线程：为工作线程服务，当所有用户线程结束，守护线程才结束。<ul><li>常见的守护线程：垃圾回收机制。</li><li>如何设置守护线程：t0.setDaemon(true);</li></ul></li></ul><div class="img-wrap"><div class="img-bg"><img class="img" src="https://s2.loli.net/2023/02/03/YFMqpA2QGLxBakj.png"/></div></div><h1 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h1><details class="folding-tag" red><summary> 线程常用方法 </summary>              <div class='content'>              <ul><li><strong>setName/getName：</strong>设置/获取线程名称</li><li><strong>start</strong>让线程执行，<strong>run</strong>调用线程对象的run方法</li><li><strong>setPriority/getPriority</strong>：更改/获取线程的优先级<ul><li>max：10   norm：5    min：1</li></ul></li><li><strong>sleep</strong>：静态方法，让制定好ms内正在执行的线程休眠</li><li><strong>interrupt</strong>：中断线程，但是没有结束线程。一般用于中断正在休眠的进程。</li><li><strong>yield</strong>：线程礼让，让出CPU让其它线程执行，但是不一定成功。</li><li><strong>join</strong>：线程插队。一旦插队成功，肯定先执行完插入到线程，再执行原线程。<ul><li>用法：在主线程内加入，t0.join();可以调用子线程。</li></ul></li></ul>              </div>            </details><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><ul><li>需求：在多线程编程中，一些敏感的数据不允许被多个线程访问，此时就使用同步访问技术，保证数据在同一时刻最多有一个线程访问，以保证数据的完整性。</li><li>实现方式：加上 Synchronized关键字<ul><li>同步代码块：在对象前加上synchronized 得到对象锁</li><li>同步方法；在方法前加上synchronized</li></ul></li><li>同步实现原理：<ul><li>所有线程去抢一把对象锁，得到锁才能进入，完成任务后继续抢锁。</li><li>没获得锁的进程处于BLOCKED阻塞状态。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="comment">/*synchronized*/</span>  <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123; <span class="comment">// 同步方法，默认锁对象为this</span></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123; <span class="comment">//同步代码块，默认</span></span><br><span class="line">        <span class="comment">//xxx</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;&#125; <span class="comment">// 静态方法，默认锁对象为当前类.class</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><ul><li>是什么：每个对象都对应一个称之为互斥锁的标记，保证任意时刻只能有一个线程访问该对象。</li><li>作用：保证共享数据操作的完整性。</li><li>实现：关键字synchronized修饰某对象，表示某对象在任意一个时刻只能由一个线程来访问。</li><li>局限性：程序的执行效率降低。</li><li>分类<ul><li>同步的非静态方法的锁，可以是this，也可以是其它对象。<strong>但是要求是同一个对象</strong></li><li>同步的静态方法的锁，为当前类本身</li></ul></li></ul><p>注意事项：</p><ul><li>同步方法如果没有static，默认锁对象为this。如果方法使用static修饰，默认锁对象为：当前类.class</li><li>实现步骤<ul><li>分析需要上锁的代码</li><li>选中同步代码块或者同步方法，推荐同步代码块</li><li>要求多个线程的锁对象必须为同一个（否则锁不住，一个锁三个门）</li></ul></li></ul><h2 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h2><ul><li>什么是死锁？多个线程占用对方的锁资源，但是互相不肯让步。</li><li>编程中要避免死锁的现象。</li></ul><p>代码演示：</p><ul><li>在下面代码中，如果flag为真，A会得到O1的对象锁，然后尝试获取O2的对象锁。如果A得不到O2对象锁，就会BLOCKED状态。如果flag为假，B会得到O2的对象锁，尝试获取O1,如果得不到O1就会BLOCKED.</li><li>这里可能A和B都拿到对象锁，但是都进行不下去。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">boolean</span> flag;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DeadLockDemo</span><span class="params">(<span class="type">boolean</span> flag)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(o1)&#123;</span><br><span class="line">                sout(Thread.currentThread().getName() + <span class="string">&quot;jinru&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span>(o2)&#123;</span><br><span class="line">                    sout(Thread.currentThread().getName() + <span class="string">&quot;jinru&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(o2)&#123;</span><br><span class="line">                sout(Thread.currentThread().getName() + <span class="string">&quot;jinru&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span>(o1)&#123;</span><br><span class="line">                    sout(Thread.currentThread().getName() + <span class="string">&quot;jinru&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MAIN内</span></span><br><span class="line"><span class="type">DeadLockDemo</span> <span class="variable">deadLoackDemo1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadLockDemo</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="type">DeadLockDemo</span> <span class="variable">deadLoackDemo2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadLockDemo</span>(<span class="literal">false</span>);</span><br><span class="line">deadLoackDemo1.start();</span><br><span class="line">deadLoackDemo2.start();</span><br></pre></td></tr></table></figure></li></ul><h2 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h2><p>下面操作为释放锁：当前线程的同步方法/同步代码块</p><ol><li>执行结束。 — <strong>厕所上完了</strong></li><li>中遇到了break或者return。  —<strong>上厕所被老板叫出来</strong></li><li>出现了未处理的Error或者Exception。—<strong>忘记带纸，不得不出来</strong></li><li>执行了线程对象的wait()方法，当前线程暂停。—<strong>暂时无法如厕，需要酝酿一下</strong></li></ol><p>下面操作不会释放锁：当前线程的同步方法/同步代码块</p><ol><li>调用了Sleep或者yield，暂停了线程的执行，不会释放锁。</li><li>其它线程调用了该线程的suspend方法将该线程挂起，从running到ready，但是仍然在runnable，不会释放锁。（ps：suspend和resume都过时了，不推荐用这两种方法来控制线程）</li></ol>]]></content>
      
      
      <categories>
          
          <category> JAVA后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习笔记2</title>
      <link href="/posts/a477b0b7.html"/>
      <url>/posts/a477b0b7.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git入门2"><a href="#Git入门2" class="headerlink" title="Git入门2"></a>Git入门2</h1><ul><li>Github   &lt;==<ul><li>push</li><li>pull</li><li>clone</li><li>SSH免密登录</li><li>Idea集成Github</li></ul></li><li>Gitee码云</li><li>Gitlab</li></ul><h1 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h1><ul><li>Git团队协作模式分为团队内协作和跨团队协作</li><li>github:全球最大的同性交友平台，技术控的天堂</li></ul><details class="folding-tag" blue><summary> GitHub远程仓库操作常见命令 </summary>              <div class='content'>              <ul><li>查看当前所有远程地址别名：<strong>git remove -v</strong></li><li>起别名： <strong>git remove add 别名 远程地址</strong></li><li>推送本地分支上的内容到远程库：<strong>git push 别名 分支</strong></li><li>将远程仓库内容克隆到本地：<strong>git clone 远程地址</strong></li><li>将远程仓库对于分支的最新内容拉下来后与当前本地分支合并<ul><li><strong>git pull 远程库地址别名 远程分支名</strong></li></ul></li></ul>              </div>            </details><ul><li>第一步：创建别名</li><li>第二步：推送，最小单位是分支<ul><li>弹出登录选项，选择浏览器登录</li><li>推送成功</li></ul></li><li>更改代码后拉去代码，保证本地库代码=远程库代码</li></ul><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><ul><li><p>演示<strong>团队内协作</strong>的过程</p><ul><li>项目领导<ul><li>Settings—ManagerAccess—Invite a collaborator —add sb to this repository</li><li>复制邀请函：也是一个URL地址</li></ul></li><li>公司开发者2<ul><li><strong>同意邀请</strong></li><li>拉取文件</li><li>修改代码</li><li>添加暂存区、提交本地库</li><li>push到远程库 git push urlname branchname</li><li><strong>提示：没权限推送</strong></li></ul></li><li>项目领导<ul><li>pull 项目到本地库</li></ul></li></ul></li><li><p>演示<strong>跨团队协作</strong>的过程</p><ul><li>团队外大佬<ul><li>找到某公司的项目，Fork到自己的仓库</li><li>修改代码</li><li>Pull Requests — New Pull request — create pull request  — 写提交信息和附带信息</li></ul></li><li>公司项目领导<ul><li>pull request — 点击分支上的提交信息可以查看代码</li><li>有疑问可以“回复团队外大佬”。</li><li>Merge pull request — comfirm merge</li><li>在自己的项目上能看到修改的代码了</li></ul></li></ul></li></ul><h2 id="SSH免密登录"><a href="#SSH免密登录" class="headerlink" title="SSH免密登录"></a>SSH免密登录</h2><ul><li>在GitBash内<ul><li>输入：ssh—keygen -t rsa -C ajaxzhan@xxx.com<ul><li>ssh—keygen命令 -t 指定算法 rsa为非对称加密协议 -C为描述</li><li>敲击三次回车</li></ul></li></ul></li><li>C盘的用户/家目录/.ssh 找到id_rsa.pub ，复制公钥</li><li>GitHub账号设置内 —SSH and GPG keys — New SSH Key — 粘贴Key</li><li>测试SSH连接，找到仓库的SSH连接，试试pull和push</li></ul><h1 id="IDEA相关"><a href="#IDEA相关" class="headerlink" title="IDEA相关"></a>IDEA相关</h1><h2 id="IDEA-集成Git"><a href="#IDEA-集成Git" class="headerlink" title="IDEA 集成Git"></a>IDEA 集成Git</h2><ul><li>配置Git忽略IDEA的配置文件，这些文件和项目没关系<ul><li>在windows用户家目录下，创建 git.ignore</li><li>配置文件在下面</li><li>然后在windows用户家目录下的gitconfig文件下一段配置，如下。</li></ul></li><li>在IDEA的设置—version control—添加Git的安装目录，显示版本号则成功</li></ul><details class="folding-tag" red><summary> git.ignore配置文件 </summary>              <div class='content'>              <p>git.ignore文件<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># Compiled class file</span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># Log file</span><br><span class="line">*.log</span><br><span class="line"></span><br><span class="line"># BlueJ files</span><br><span class="line">*.ctxt</span><br><span class="line"></span><br><span class="line"># Mobile Tools for Java (J2ME)</span><br><span class="line">.mtj.tmp/# Package Files #</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.nar</span><br><span class="line">*.ear</span><br><span class="line">*.zip</span><br><span class="line">*.tar.gz</span><br><span class="line">*.rar</span><br><span class="line"></span><br><span class="line">hs_err_pid*</span><br><span class="line"></span><br><span class="line">.classpath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">target</span><br><span class="line">.idea</span><br><span class="line">*.iml</span><br></pre></td></tr></table></figure></p><p>下面这段在gitconfig上添加。注意注意注意，将路径中的 <strong>‘\’</strong> 改成 <strong>‘/‘</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">excludesfile = 你的gitignore地址</span><br></pre></td></tr></table></figure></p>              </div>            </details><ul><li>初始化本地库和提交<ul><li>菜单栏 — VCS —- create git repository — 选中项目目录 — ok</li><li>看到文件变红，表示文件未被追踪</li><li>右键文件 — Git — Add</li><li>看到文件变绿</li><li>在main内创建个包，简单写点代码</li><li>直接右键项目根目录 — Git — Add — 提示是否添加ignore文件— cancel（也可能没提示，不用管）</li><li>右键 git — commit</li></ul></li><li>切换版本：左下角 — git — 找到要切换的版本 — 右键checkout</li><li>分支<ul><li>右键项目根目录 — git  -  - branches — new Branch<ul><li>或者右下角单击当前分支</li></ul></li><li>可以新建、切换分支</li></ul></li><li>合并分支<ul><li>在hot-fix分支修改代码并提交</li><li>切换回master分支，右键hox-fix，Merge into current</li></ul></li></ul><h2 id="IDEA集成GitHub"><a href="#IDEA集成GitHub" class="headerlink" title="IDEA集成GitHub"></a>IDEA集成GitHub</h2><ul><li>添加GitHub账号<ul><li>IDEA内：settings — version control — github — add a account</li><li>GitHub：设置 — developer settings — personal access tokens<ul><li>权限全选，生成口令，<strong>复制口令</strong></li></ul></li><li>返回IDEA内，粘贴，登录成功</li></ul></li><li>分享项目到GitHub<ul><li>VCS — share project on github — 创建远程库</li></ul></li><li>推送项目到GitHub<ul><li>VCS — push</li><li>默认用HTTPS协议</li><li>推荐用SSH协议：提交页面上的master — define remote —将自己的SSH url 粘贴进去 — 成功后，右键选用 — push</li><li>打开GitHub页面，发现成功</li><li><strong>注意；动手改本地代码前，一定要检查本地库代码和远程库代码的区别。如果本地库版本落后了，切记先pull最新代码，然后再写代码。</strong></li></ul></li><li>拉取远程库代码到本地<ul><li>pull就得了。可以通过SSH或者HTTP</li></ul></li><li>克隆代码到本地</li></ul><h1 id="码云Gitee"><a href="#码云Gitee" class="headerlink" title="码云Gitee"></a>码云Gitee</h1><blockquote><p>和GitHub基本相同</p></blockquote><h1 id="自建代码托管平台GitLab"><a href="#自建代码托管平台GitLab" class="headerlink" title="自建代码托管平台GitLab"></a>自建代码托管平台GitLab</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>乌克兰程序员用Ruby语言开发，后来用Go重写。GitLab被IBM、Sony、阿里等大公司使用。</li><li>官网地址：<a href="https://about.gitlab.com/">https://about.gitlab.com/</a></li><li>安装：选择自己的服务器版本/k8s/docker …</li></ul><blockquote><p>其它的需要有Linux和服务器相关知识，我一小白学了也没用。</p><p>完结撒花！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础(二)</title>
      <link href="/posts/79ae3849.html"/>
      <url>/posts/79ae3849.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-二"><a href="#MySQL-二" class="headerlink" title="MySQL (二)"></a>MySQL (二)</h1><ul><li>数据表 和 CRUD</li><li>约束Constraint</li><li>存储引擎</li><li>事务Transaction</li><li>索引</li><li>视图</li><li>数据库涉及三范式</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础(一)</title>
      <link href="/posts/d69fa32b.html"/>
      <url>/posts/d69fa32b.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-之-DQL专场"><a href="#MySQL-之-DQL专场" class="headerlink" title="MySQL 之 DQL专场"></a>MySQL 之 DQL专场</h1><ul><li>SQL基本术语和概念</li><li>简单查询和条件查询</li><li>排序 Order by</li><li>分组函数和Group by</li><li>连接查询SQL99语法<ul><li>笛卡尔积现象</li><li>内连接</li><li>外连接</li></ul></li><li>子查询</li><li>分页查询</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习笔记1</title>
      <link href="/posts/3d7ee10d.html"/>
      <url>/posts/3d7ee10d.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git入门1"><a href="#Git入门1" class="headerlink" title="Git入门1"></a>Git入门1</h1><ul><li>Git  &lt;==<ul><li>分布式版本管理系统 VS 集中式版本控制工具</li><li>Git命令</li><li>Git分支</li><li>Idea 集成Git</li></ul></li><li>Github<ul><li>push</li><li>pull</li><li>clone</li><li>SSH免密登录</li><li>Idea集成Github</li></ul></li><li>Gitlab</li></ul><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="Git概述"><a href="#Git概述" class="headerlink" title="Git概述"></a>Git概述</h2><ul><li>Git：免费开源的分布版本控制系统。</li><li>优点：占地面积小，性能极快，免费开源，有廉价的本地库、方便的暂存区以及分支。</li><li>版本控制：记录文件内容变化，方便查阅特定版本修订情况。</li></ul><h2 id="集中式版本控制工具-VS-分布式版本控制系统"><a href="#集中式版本控制工具-VS-分布式版本控制系统" class="headerlink" title="集中式版本控制工具 VS 分布式版本控制系统"></a>集中式版本控制工具 VS 分布式版本控制系统</h2><p><strong>集中式版本控制系统</strong></p><ul><li>集中化的版本控制系统：SVN\CVS。</li><li>特点：<ul><li>有单一的集中控制服务器，保存所有文件修订版本。</li><li>客户端连接到服务器，取出最新文件或者提交更新。</li></ul></li><li>缺点：<ul><li>如果中央服务器挂了，大家都没法工作。</li></ul></li></ul><p><strong>分布式版本控制系统</strong></p><ul><li>每台电脑都可以<strong>进行本地的版本控制</strong>，即使远程库挂了，只不过没法推送罢了。</li><li>每个客户端保存的也都是完整的项目（包含历史记录，更加安全）</li><li>Git的历史吹水<ul><li>Linus本人手动合并代码来更新Linux</li><li>商业软件BitKeeper人道主义免费授权，但是要求不能被破解。</li><li>05年有人破解了，收回使用权。Linus用C语言两周开发了Git。</li><li>08年GitHub上线，jQuery、Ruby、PHP都将代码放到GitHub上开源</li></ul></li></ul><h2 id="Git工作区域"><a href="#Git工作区域" class="headerlink" title="Git工作区域"></a>Git工作区域</h2><p>工作区：代码存放的磁盘位置。—&gt;git add  暂存区 —&gt;git commit 本地库，存储历史版本。（生成版本后就删不掉了）—&gt;git push 推送到远程库</p><p><strong>代码托管重心—远程库</strong></p><ul><li>局域网：gitlab</li><li>互联网：GitHub、gitee</li></ul><h2 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h2><details class="folding-tag" blue><summary> Git常用命令 </summary>              <div class='content'>              <ul><li>设置用户签名：<ul><li>git config —global user.name 用户名</li><li>git config —global user.email 邮箱</li></ul></li><li>初始化本地库：git init</li><li>查看本地库状态：git status</li><li>添加到暂存区：git add 文件名</li><li>提交到本地库：git commit -m “日志信息” 文件名</li><li>查看历史记录：git reflog</li><li>版本穿梭：git reset —hard 版本号</li></ul>              </div>            </details><h3 id="设置用户签名"><a href="#设置用户签名" class="headerlink" title="设置用户签名"></a>设置用户签名</h3><p>签名作用：区分不同操作者身份。在每个版本的提交者信息可以看到。<br>git首次安装必须设置一下用户签名。这里的用户前面和GitHub上没有关系。</p><h3 id="初始化本地库"><a href="#初始化本地库" class="headerlink" title="初始化本地库"></a>初始化本地库</h3><p>查看隐藏文件：ll -a</p><h3 id="演示git-status"><a href="#演示git-status" class="headerlink" title="演示git status"></a>演示git status</h3><p>未添加的提示信息：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line">No commits yet</span><br><span class="line">Untracked files: 未被追踪的文件，在工作区</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">        cpp/</span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track) </span><br></pre></td></tr></table></figure></p><p>执行<strong>git add cpp/</strong> 后: 添加到暂存区<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line">No commits yet</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>执行<strong>git commit -m “C++刷题第一版” /cpp</strong>后：提交到本地库<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure></p><h3 id="历史版本和版本穿梭"><a href="#历史版本和版本穿梭" class="headerlink" title="历史版本和版本穿梭"></a>历史版本和版本穿梭</h3><ul><li>查看版本信息：git reflog 查看版本信息、版本号、指针</li><li>查看详细信息：git log 查看提交者和提交时间</li><li><p>穿越版本，复制版本号后：git reset —hard 版本号</p><ul><li>这时候查看文件内容，就会发现内容发生变化。</li></ul></li><li><p>git切换版本，底层其实是移动HEAD指针。</p><ul><li>HEAD-&gt;MASTER-&gt;FIRST</li><li>每次移动都是改动MASTER</li></ul></li></ul><h2 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h2><p><strong>分支理解</strong><br>使用分支：程序员将自己工作从主线上分离开来，开发自己分支的时候不会影响主线。<br>分支可以简单理解为副本，底层实际上是指针引用。</p><p>主线分支1.0 —》颜色分支改动后合并到主线 —》主线分支1.1<br>游戏分支经历4个版本后合并到主线 —》主线分支1.2</p><ul><li>分支好处：<ul><li>同时并行推进多个功能开发，提高开发效率。</li><li>某个分支开发失败，对其它分支不会有影响。</li></ul></li></ul><details class="folding-tag" blue><summary> Git分支命令 </summary>              <div class='content'>              <ul><li>创建分支<ul><li>git branch 分支名</li></ul></li><li>查看分支<ul><li>git branch -v</li></ul></li><li>切换分支<ul><li>git checkout 分支名</li></ul></li><li>把指定分支合并到当前分支<ul><li>git merge 分支名</li><li>在master上执行merge hot-fix 就是把hot-fix融到master上</li><li>正常合并：hot分支 基于master分支没改动 的基础上修改并merge。</li><li>冲突合并：合并分支的时候，在同一个文件的同一个位置有两套完全不同的修改。git无法决定使用哪一个，必须人为决定新代码的内容。</li></ul></li></ul>              </div>            </details><h3 id="演示冲突合并"><a href="#演示冲突合并" class="headerlink" title="演示冲突合并"></a>演示冲突合并</h3><ul><li>冲突后merge时：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Auto-merging hello.txt</span><br><span class="line">CONFLICT (content): Merge conflict in hello.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br><span class="line">状态：</span><br><span class="line"> (master|MERGING)</span><br></pre></td></tr></table></figure><ul><li>修改文件，vim hello.txt 人工增删 并且删掉特殊符号</li><li>add到暂存区</li><li>commit，<strong>注意不能带文件名！因为有两个分支</strong></li><li>注意：只会修改master分支，不会修改hot-fix</li></ul><h3 id="移动分支的本质"><a href="#移动分支的本质" class="headerlink" title="移动分支的本质"></a>移动分支的本质</h3><p>master、hot-fix都是指向具体版本记录的指针。<br>当前所在的指针其实由HEAD决定，创建分支就是多创建一个指针。<br>切换分支的本质就是移动HEAD指针。</p>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础数论</title>
      <link href="/posts/b03619bf.html"/>
      <url>/posts/b03619bf.html</url>
      
        <content type="html"><![CDATA[<h1 id="数学知识-一-之基本数论"><a href="#数学知识-一-之基本数论" class="headerlink" title="数学知识(一)之基本数论"></a>数学知识(一)之基本数论</h1><ul><li>质数<ul><li>质数的判定：试除法</li><li>分解质因数：试除法</li><li>质数筛<ul><li>朴素质数筛</li><li>埃式筛</li><li>线性筛</li></ul></li></ul></li><li>约数<ul><li>求约数，试除法</li><li>约数和定理</li><li>约数个数定理</li><li>欧几里得算法（辗转相除法）求最大公约数</li></ul></li><li>欧拉函数<ul><li>欧拉函数</li><li>筛法求欧拉函数</li></ul></li><li>快速幂</li><li>扩展欧几里得算法</li><li>中国剩余定理</li></ul><h1 id="质数专题"><a href="#质数专题" class="headerlink" title="质数专题"></a>质数专题</h1><h2 id="质数的判定：试除法"><a href="#质数的判定：试除法" class="headerlink" title="质数的判定：试除法"></a>质数的判定：试除法</h2>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论(三)</title>
      <link href="/posts/b3ead680.html"/>
      <url>/posts/b3ead680.html</url>
      
        <content type="html"><![CDATA[<h1 id="图论之最小生成树与二分图"><a href="#图论之最小生成树与二分图" class="headerlink" title="图论之最小生成树与二分图"></a>图论之最小生成树与二分图</h1><p><img src="https://s2.loli.net/2023/01/31/BgiVpFajKlNMu43.png" alt="图论三" title="图论三"></p><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><p>Prim实现方式和dijkstra很相似。<br>步骤：</p><ul><li>将所有的距离初始化为INF</li><li>迭代n次<ul><li>找到不在集合当中的距离最小的点t。集合s表示当前已经在连通块中的所有点。</li><li>用t更新其它点到集合的距离</li><li>把t加到集合中去</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Prim算法求最小生成树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>,INF= <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> g[N][N];    <span class="comment">//存储图</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">//存储各个节点到生成树的距离</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">//节点是否被加入到生成树中</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">//记录是树的权重之和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="comment">//找到距离树最近的点</span></span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t==<span class="number">-1</span> || dist[t] &gt; dist[j])) t = j;</span><br><span class="line">        <span class="comment">//如果不是第一个点，但是距离是无穷大，就说明没有最小生成树</span></span><br><span class="line">        <span class="keyword">if</span>(i &amp;&amp; (dist[t] == INF)) <span class="keyword">return</span> INF;</span><br><span class="line">        <span class="comment">//先更新距离，防止自环。</span></span><br><span class="line">        <span class="keyword">if</span>(i) res+= dist[t];</span><br><span class="line">        st[t] = <span class="literal">true</span>; <span class="comment">//将t加入到集合中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span> ;j&lt;=n ;j++) dist[j] = <span class="built_in">min</span>(dist[j],g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        g[a][b] = g[b][a] = <span class="built_in">min</span>(g[a][b],c);<span class="comment">//处理重边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">prim</span>();</span><br><span class="line">    <span class="keyword">if</span>(t == INF) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h2><p>很优美的算法，复习完并查集食用效果更佳。</p><p>步骤：</p><ul><li>将所有边按照权重从小到大排序。（可以用快排）O(MlogM)但是常数很小。</li><li>从小到大枚举每条边 a-b权重c （可以用并查集）O(M)<ul><li>如果a b 不连通（并查集Q操作），将这条边加入到集合中（并查集C操作）。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">kruskal算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">//并查集的父节点数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b,w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge &amp;W)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;W.w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里重载小于号，升序排序</span></span><br><span class="line">&#125;edges[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] !=x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;w);</span><br><span class="line">        edges[i] = &#123;a,b,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//快排</span></span><br><span class="line">    <span class="built_in">sort</span>(edges,edges+m);</span><br><span class="line">    <span class="comment">//枚举每条边，判断是否连同</span></span><br><span class="line">    <span class="comment">//刚开始，都是自己一个集合</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i]= i;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>,cnt = <span class="number">0</span>; <span class="comment">//res记录生成树的权重，cnt记录连通的边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b= edges[i].b, w = edges[i].w;</span><br><span class="line">        a = <span class="built_in">find</span>(a);</span><br><span class="line">        b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(a!=b)&#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res+=w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &lt; n<span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><h2 id="染色法—判断二分图"><a href="#染色法—判断二分图" class="headerlink" title="染色法—判断二分图"></a>染色法—判断二分图</h2><ul><li>二分图：将所有点分成两个集合，使得所有的边只出现在集合之间，就是二分图。</li><li>染色法是什么？用于判断一个图是否为二分图。</li><li>可以证明：一个图是二分图，当且仅当图中不含奇数环。（图论内的性质）<ul><li>奇数环：环中边数为奇数。</li></ul></li><li>步骤,color用1和2区分<ul><li>遍历所有的点<ul><li>每次将未染色的点i进行dfs染色</li><li>某个点染色失败相当于存在相邻2个点染成了相同的颜色。</li></ul></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">染色法判断二分图</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>,M = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],e[M],ne[M],idx; <span class="comment">//  经典邻接表存储无向图</span></span><br><span class="line"><span class="type">int</span> color[N]; <span class="comment">// 保存两种颜色，分别是1，2和0未染色</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u , <span class="type">int</span> c)</span></span>&#123; <span class="comment">//深度优先遍历</span></span><br><span class="line">    color[u] = c; <span class="comment">// 染色</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!color[j])&#123; <span class="comment">// 相邻的点没有染色，则递归操作</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(j,<span class="number">3</span>-c)) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 保证颜色不同</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//颜色相同</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>; <span class="comment">//判断染色过程中是否有矛盾出现</span></span><br><span class="line">    <span class="comment">//染色过程，遍历每一个点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!color[i])&#123; <span class="comment">// 没有染色则将所有相邻点染色</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(i,<span class="number">1</span>))&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匈牙利算法-—-二分图最大匹配"><a href="#匈牙利算法-—-二分图最大匹配" class="headerlink" title="匈牙利算法 — 二分图最大匹配"></a>匈牙利算法 — 二分图最大匹配</h2><p><img src="https://s2.loli.net/2023/01/31/xGjHLPvANBCuIZr.gif" alt="匈牙利算法演示图" title="匈牙利算法"></p><ul><li>月老算法\海王算法\非诚勿扰算法[doge]</li><li>O(N*M)最坏需要遍历M条边，实际上运行时间不用这么多。</li></ul><blockquote><p>匹配：在图论中，一个「匹配」是一个边的集合，其中任意两条边都没有公共顶点。<br>最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。</p></blockquote><p>详细奇怪注释的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">二分图最大匹配</span></span><br><span class="line"><span class="comment">匈牙利算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>,M = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n1,n2,m; <span class="comment">// 表示两个集合内的点数</span></span><br><span class="line"><span class="type">int</span> h[N],ne[M],e[M],idx;</span><br><span class="line"><span class="comment">//临时匹配数组，一轮匹配过程中女孩j被男孩a先匹配了。 st[j] = a;</span></span><br><span class="line"><span class="comment">//用于判重，不要重复搜索一个点。</span></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="comment">//match[j]= a; 表示女孩j现在的男友是a</span></span><br><span class="line"><span class="type">int</span> match[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[x];i!=<span class="number">-1</span>;i=ne[i])&#123; <span class="comment">//枚举这个男生看上的妹子</span></span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[j])&#123; <span class="comment">// 没考虑过这个妹子</span></span><br><span class="line">            st[j] = <span class="literal">true</span>; <span class="comment">// 考虑</span></span><br><span class="line">            <span class="comment">//经典一步</span></span><br><span class="line">            <span class="comment">//妹子没男友 或者 妹子有男友但是男友有备胎</span></span><br><span class="line">            <span class="keyword">if</span>(match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))&#123; </span><br><span class="line">                match[j] = x; <span class="comment">// 妹子匹配男子</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 实在不行就找不到了。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n1, &amp;n2, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span> (m -- )&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">// 当前匹配的数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n1;i++)&#123; <span class="comment">// 遍历第一个集合</span></span><br><span class="line">        <span class="built_in">memset</span>(st,<span class="literal">false</span>,<span class="keyword">sizeof</span> st); <span class="comment">// 将所有考虑的第二个集合清空</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(i)) res++; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>图论题,解图过程才是难点，写出图论模板只是跨入了那道门槛。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论(二)</title>
      <link href="/posts/cd19f6ab.html"/>
      <url>/posts/cd19f6ab.html</url>
      
        <content type="html"><![CDATA[<h1 id="图论之最短路算法专题"><a href="#图论之最短路算法专题" class="headerlink" title="图论之最短路算法专题"></a>图论之最短路算法专题</h1><p><img src="https://s2.loli.net/2023/01/30/vGjNmKIfV7kMt5W.png" alt="最短路算法体系" title="最短路算法体系"></p><h1 id="朴素dijkstra"><a href="#朴素dijkstra" class="headerlink" title="朴素dijkstra"></a>朴素dijkstra</h1><h2 id="一个不错的dijkstra演示"><a href="#一个不错的dijkstra演示" class="headerlink" title="一个不错的dijkstra演示"></a>一个不错的dijkstra演示</h2><div class="tag link"><a class="link-card" title="dijkstra演示" href="https://www.bilibili.com/video/BV1zz4y1m7Nq"><div class="left"><img src="https://www.bilibili.com/favicon.ico?v=1"/></div><div class="right"><p class="text">dijkstra演示</p><p class="url">https://www.bilibili.com/video/BV1zz4y1m7Nq</p></div></a></div><h2 id="dijkstra实现步骤"><a href="#dijkstra实现步骤" class="headerlink" title="dijkstra实现步骤"></a>dijkstra实现步骤</h2><blockquote><p>感觉学算法就是【理解算法】【理解算法代码】【实践算法代码】【运用算法代码】</p></blockquote><p>原理：基于贪心。<br>存储：朴素dijkstra适合稠密图。<br>属性：集合s—存当前已经确定最短距离的点。dis—存每个点到起点的距离<br>步骤：</p><ol><li>初始化所有点到起点的距离：dist[1] = 0; dist[i] = inf; </li><li>迭代n次，确定n个点到起点的最短距离<ol><li>找到不在s中的，距离最近的点t。【n方次】—》堆可以变  【1次】</li><li>把t加到s中。【n次】</li><li>用t更新其它点的距离：看dis[x]是否大于dis[t] + w 大于就更新。【m次】—》堆变 【m次，每次logN】</li></ol></li></ol><p>详细注释的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">朴素dijkstra</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// 从起点走到每个点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 每个点的最短路是否确定</span></span><br><span class="line"><span class="comment">//存在重边和自环的处理： 所有边为正，自环不存在最短路，重边只需要保留距离最短的边</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist); <span class="comment">//初始化距离</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 起点的距离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123; <span class="comment">// 迭代n次</span></span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>; <span class="comment">// 距离最近的点</span></span><br><span class="line">        <span class="comment">//查找点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123; </span><br><span class="line">            <span class="comment">//找寻不在集合s中   并且    距离最近的点t</span></span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t==<span class="number">-1</span> || dist[t] &gt; dist[j])) t = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//利用这个点t，更新下一个点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123; </span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j],dist[t] + g[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将t加入集合</span></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        g[a][b] = <span class="built_in">min</span>(g[a][b],c);<span class="comment">//重边的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">dijkstra</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="dijkstra堆优化"><a href="#dijkstra堆优化" class="headerlink" title="dijkstra堆优化"></a>dijkstra堆优化</h1><p>堆的写法：<br>①手写堆：元素个数n。<br>②优先队列：好写但是每次都要插入新的数，元素个数m。—&gt; mlogm 又因为 m&lt;=n^2 取对数后，logm&lt;=2logn，所以时间复杂度一样。<br>一般为了方便，用优先队列来写就行。<br>存储：邻接表。ps：邻接表不需要处理重边。<br>priority_queue写法：<br>priority_queue&lt;内部装的元素类型&gt;:大顶堆，默认降序。<br>priority_queue&lt;类型,用什么容器,排序规则&gt;;</p><p>详细注释的代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">dijkstra 堆优化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">150010</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII; </span><br><span class="line"><span class="comment">//堆优化版，属于稀疏图，用邻接表进行存储</span></span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="comment">//dijkstra两个数组：存放距离源点距离和是否确定最短路径</span></span><br><span class="line"><span class="comment">//算法本身保证，重边是不用管的。</span></span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y , <span class="type">int</span> c)</span></span>&#123;<span class="comment">//邻接表的添加，多了个权重</span></span><br><span class="line">    w[idx] = c;</span><br><span class="line">    e[idx] = y;</span><br><span class="line">    ne[idx] = h[x];</span><br><span class="line">    h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt;heap;<span class="comment">// 定义小根堆</span></span><br><span class="line">    <span class="comment">//堆优化目的：最快找出距离最短的点，所以first存放距离，second存放点</span></span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);<span class="comment">//注意不要存放反</span></span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())&#123;</span><br><span class="line">        PII t= heap.<span class="built_in">top</span>(); <span class="comment">///找到距离最短的点</span></span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//ver 是点的编号， distance 是距离</span></span><br><span class="line">        <span class="type">int</span> ver = t.second, distance = t.first;</span><br><span class="line">        <span class="keyword">if</span>(st[ver]) <span class="keyword">continue</span>; <span class="comment">// ver点出现过</span></span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//通过这个最近的点，更新其他点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[ver];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; distance + w[i])&#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j],j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> x,y,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(x,y,c);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dijkstra</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Bellman-Ford算法-解决负权边"><a href="#Bellman-Ford算法-解决负权边" class="headerlink" title="Bellman-Ford算法 解决负权边"></a>Bellman-Ford算法 解决负权边</h1><blockquote><p>我感觉这一块《啊哈！算法》讲的挺好的。</p></blockquote><p>实现步骤：</p><ul><li>迭代n次<ul><li>备份dist数组到backup—防止“串联”现象</li><li>迭代所有边a,b,w（Bellman-Ford随便存，能遍历就行。所以一般定义个结构体）<ul><li>dist[b] = min(dist[b],dist[a]+w) 这个过程叫“松弛”操作。</li></ul></li></ul></li></ul><p>注意事项：</p><ul><li>进行k次迭代的含义：得到1号顶点最多经过k条边到达其余各顶点的最短路径长度。</li><li>可证明：迭代后所有边满足dist[b] &lt;= dist[a] + w 三角不等式</li><li>为什么只有n-1条边？如果有负权回路（一圈的长度&lt;0），可以转无穷多圈，所以就不存在最短路。</li><li>如何理解backup数组和串联现象？（建议跟着画图）<ul><li>举例：{1,2,1}{1,3,3}{2,3,1}情况下，第一次会将2更新为1，同时也会将3更新为2。但是，题目有经过k条边的限制，假设k=1，这时候就3这个点就出错了，举例应该是3而不是2。</li><li>正确的做法是：用上一轮的更新的距离，即无穷大来更新3，这样就不会出现问题。</li></ul></li><li>如何理解最后的判断是 dist[n] &gt; inf/2 而不是 &gt; inf。<ul><li>因为存在负权边。</li></ul></li></ul><p>详细注释的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">由于限制了k条边，所以就算存在负权回路，也不会无限陷入转圈，因此没事。</span></span><br><span class="line"><span class="comment">Bellman-Ford算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span> , M = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">&#125;edge[M]; <span class="comment">//保存边</span></span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> back[N];<span class="comment">//back 数组，防止串联现象</span></span><br><span class="line"><span class="type">int</span> n,m,k; <span class="comment">// k表示最短路径最多经过k条边</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123; <span class="comment">// 题目要求的k次</span></span><br><span class="line">        <span class="built_in">memcpy</span>(back,dist,<span class="keyword">sizeof</span> dist);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="comment">//遍历所有边</span></span><br><span class="line">            <span class="type">int</span> a = edge[j].a,b = edge[j].b,w = edge[j].w;</span><br><span class="line">            <span class="comment">//更新</span></span><br><span class="line">            dist[b] = <span class="built_in">min</span>(dist[b],back[a] + w);<span class="comment">//使用back数组避免串联现象</span></span><br><span class="line">            <span class="comment">//所谓串联现象，就是给a更新后立刻给b进行了更新，这样b的最短路径就不满足题目要求的经过了k条边了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span> ) <span class="keyword">return</span> <span class="number">-165592</span>; <span class="comment">//这里是为了处理负边对长度的影响</span></span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;w);</span><br><span class="line">        edge[i] = &#123;a,b,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">bellman_ford</span>();</span><br><span class="line">    <span class="keyword">if</span>(res ==<span class="number">-165592</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h1><h2 id="SPFA求最短路"><a href="#SPFA求最短路" class="headerlink" title="SPFA求最短路"></a>SPFA求最短路</h2><div class="tag link"><a class="link-card" title="解释SPFA写得很详细" href="https://www.acwing.com/solution/content/9306/"><div class="left"><img src="https://cdn.acwing.com/static/web/img/favicon.ico"/></div><div class="right"><p class="text">解释SPFA写得很详细</p><p class="url">https://www.acwing.com/solution/content/9306/</p></div></a></div><ul><li>要求：图中不含负权回路。（99%的最短路问题都没有负权回路。）（由于用了队列来存储，只要发生了更新就会不断的入队，因此假如有负权回路请你不要用SPFA否则会死循环。）</li><li>优化：实现了对Bellman-Ford的队列优化。（从a-&gt;b 只有a变小了，才会对b的更新有贡献。）</li><li>SPFA和dijkstra的区别：<blockquote><p>1] Dijkstra算法中的st数组保存的是当前确定了到源点距离最小的点，且一旦确定了最小那么就不可逆了(不可标记为true后改变为false)；SPFA算法中的st数组仅仅只是表示的当前发生过更新的点，且spfa中的st数组可逆(可以在标记为true之后又标记为false)。顺带一提的是BFS中的st数组记录的是当前已经被遍历过的点。<br>2] Dijkstra算法里使用的是优先队列保存的是当前未确定最小距离的点，目的是快速的取出当前到源点距离最小的点；SPFA算法中使用的是队列(你也可以使用别的数据结构),目的只是记录一下当前发生过更新的点。</p></blockquote></li><li></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">SPFA算法，推荐使用。甚至很多正权图的题用SPFA也能过。</span></span><br><span class="line"><span class="comment">如果被出题人构造数据卡掉，就用dijkstra堆优化。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// 各点到源点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y , <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    e[idx] = y;</span><br><span class="line">    ne[idx] = h[x];</span><br><span class="line">    h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 防止队列存储重复的点。</span></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>; <span class="comment">//不在队列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])&#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> x,y,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(x,y,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">spfa</span>();</span><br><span class="line">    <span class="keyword">if</span>(res == <span class="number">0x3f3f3f3f</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SPFA求负环"><a href="#SPFA求负环" class="headerlink" title="SPFA求负环"></a>SPFA求负环</h2><p>dist[x]：表示从1到x的最短距离。<br>cnt[x]: 当前最短路的边数。<br>在某个时候如果cnt[x]&gt;=n 的话，根据抽屉原理，一定有n+1个点，而只有n个点，说明一定存在环。由于这个环能为“最短”贡献，因此一定是个负环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">SPFA求负环</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];</span><br><span class="line"><span class="comment">//cnt记录从1到x的最短路，当cnt[i]&gt;=n 必然有环，并且一定是负环。</span></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="comment">//判断当前的点是否已经加入到队列中，如果已经加入，就不需要反复加入了。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//不需要dist数组：如果存在负环，不管dist初始化为多少，都会被更新</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不是从1开始，因为从1开始可能到不了有负环的点。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] +w[i])&#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="comment">//更新边数</span></span><br><span class="line">                cnt[j] = cnt[t]  +<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j] &gt;= n)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">spfa</span>()) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多源汇最短路：Floyd算法"><a href="#多源汇最短路：Floyd算法" class="headerlink" title="多源汇最短路：Floyd算法"></a>多源汇最短路：Floyd算法</h1><ul><li>存储：邻接矩阵。用d[i,j]存储所有的边</li><li>步骤：<ul><li>三种循环，每次从1到n</li><li>d[i,j] = min(d[i,j],d[i,k] + d[k,j])</li></ul></li><li>原理：基于动态规划d[k,i,j]从i出发只经过1-k的点到达j的最短距离。<ul><li>d[k,i,j] = d[k-1,i,k] + d[k-1,k,j]</li><li>第一维可以去掉：d[i,j] = d[i,k] + d[k,j]</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Floyd算法</span></span><br><span class="line"><span class="comment">可以处理负权，但是不能处理负权回路。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>,INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n,m,Q;</span><br><span class="line"><span class="type">int</span> d[N][N];<span class="comment">//矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j],d[i][k] + d[k][j]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;Q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(i==j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF; <span class="comment">// 处理自环</span></span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        d[a][b] = <span class="built_in">min</span>(d[a][b],c); <span class="comment">// 处理重边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">floyd</span>();</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="type">int</span> t = d[a][b];</span><br><span class="line">        <span class="keyword">if</span>(t &gt; INF/<span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论(一)</title>
      <link href="/posts/62286dc9.html"/>
      <url>/posts/62286dc9.html</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol><li>基础搜索：DFS 和 BFS</li><li>图的存储方式</li><li>图的遍历方式</li><li>有向图的拓扑序列</li></ol><h1 id="基础搜索"><a href="#基础搜索" class="headerlink" title="基础搜索"></a>基础搜索</h1><p>DFS最重要的是：考虑什么样的顺序进行遍历。DFS重点概念：回溯、剪枝</p><h2 id="DFS经典引入：数的全排列"><a href="#DFS经典引入：数的全排列" class="headerlink" title="DFS经典引入：数的全排列"></a>DFS经典引入：数的全排列</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> path[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == n)&#123;</span><br><span class="line">        <span class="comment">//搜索到当前节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,path[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//枚举全排列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(![st])&#123;</span><br><span class="line">            <span class="comment">//没走过</span></span><br><span class="line">            path[u] = i;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(u+<span class="number">1</span>);</span><br><span class="line">            st[i] = <span class="literal">false</span>;<span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DFS经典问题：N皇后问题"><a href="#DFS经典问题：N皇后问题" class="headerlink" title="DFS经典问题：N皇后问题"></a>DFS经典问题：N皇后问题</h2><p>题目描述：n*n棋盘，任意皇后不可以在同一行、同一列、同一斜线。输出满足条件的棋子摆法。</p><p><strong>搜索方式1：按行搜索，每行最多就放一个</strong></p><p>基本属性：col[N]列是否存放;dg[N]斜对角;udg[N]斜对角线</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> col[N],dg[N],udg[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( u == n)&#123;</span><br><span class="line">        <span class="comment">//找到最后一行，输出地图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">puts</span>(g[i]); </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//搜索每一列</span></span><br><span class="line">        <span class="keyword">if</span>(!col[i] &amp;&amp; !dg[u+i] &amp;&amp; !udg[i-u +n])&#123;</span><br><span class="line">            <span class="comment">//如果满足条件，注意反对角线为了防止变成负数加个n</span></span><br><span class="line">            g[u][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            col[i] = dg[u+i] = udg[i-u+n] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(u+<span class="number">1</span>);</span><br><span class="line">            col[i] = dg[u+i] = udg[i-u+n] = <span class="literal">false</span>;</span><br><span class="line">            g[u][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>搜索方式2：争对每个格子有放和不放两种选择</strong><br>dfs(x,y,z)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">bool</span> row[N],col[N],dg[N],udg[N];</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y , <span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s &gt; n) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//枚举顺序，先枚举第一行第一列，再第二行</span></span><br><span class="line">    <span class="keyword">if</span>(y == n) y=,x++;</span><br><span class="line">    <span class="keyword">if</span>(x == n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == n)&#123; <span class="comment">//为目标</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">puts</span>(g[i]);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//两种选择：放/不放</span></span><br><span class="line">    <span class="comment">//不放</span></span><br><span class="line">    g[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(x,y+<span class="number">1</span>,s);</span><br><span class="line">    <span class="comment">//放</span></span><br><span class="line">    <span class="keyword">if</span>(!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x+y] &amp;&amp; !udg[x-y+n])&#123;</span><br><span class="line">        row[x] = col[y] = dg[x+y] = udg[x - y +n] = <span class="literal">true</span>;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(x,y+<span class="number">1</span>,s+<span class="number">1</span>);</span><br><span class="line">        g[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        row[x] = col[y] = dg[x+y] = udg[x - y + n] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BFS经典例题：迷宫最短路"><a href="#BFS经典例题：迷宫最短路" class="headerlink" title="BFS经典例题：迷宫最短路"></a>BFS经典例题：迷宫最短路</h2><p>应用场景：如果边权均为1，则可以用来BFS来解决最短路问题。<br>题目描述：从(1,1)出发，每次只能向上下左右移动，问移动到(n,m)至少要移动多少次。<br>地图中0为可走，1为不可走。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> g[N][N],d[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;PII&gt;q;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="type">int</span> dx = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> nx = t.first + dx[i];</span><br><span class="line">            <span class="type">int</span> ny = t.second + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx &gt;=<span class="number">0</span> &amp;&amp; nx &lt;n; &amp;&amp; ny&gt;=<span class="number">0</span> &amp;&amp; ny&lt;m &amp;&amp; g[nx][ny]==<span class="number">0</span> &amp;&amp; d[nx][ny]==<span class="number">-1</span>)&#123;</span><br><span class="line">                d[nx][ny] = d[t.first][t.second]+<span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;nx,ny&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="图和树的存储"><a href="#图和树的存储" class="headerlink" title="图和树的存储"></a>图和树的存储</h1><p>图和树的存储:</p><p>图：无向图和有向图。无向图可以看成是特殊的有向图，因此只需要考虑如何存储有向图。<br>存储图的手段一般用两种：稠密图用邻接矩阵，稀疏图用邻接表。邻接矩阵用g[a][b]存储a到b的信息，邻接表为每个节点开个单链表，存这个点可走到哪个节点。</p><p>邻接表的基本属性:</p><p>h[N]为n个链表头，e[M]存储值，ne[M]存储下一个节点，idx存储当前的节点。<br>初始化操作：头节点全部指向-1<br>插入a到b：在a的头节点头插一个b。</p><h1 id="图和树的遍历"><a href="#图和树的遍历" class="headerlink" title="图和树的遍历"></a>图和树的遍历</h1><h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><p><strong>好题引入：树的重心</strong></p><p>题目介绍<br>树的中心指树的一个节点，如果删掉此节点，使各个连通块内点数的最大值最小。<br>输出一个整数表示将重心删除后，剩余各个连通块中点数的最大值。</p><p>思路</p><ul><li>每个点删掉后连通块内点数的最大值，每个点对应一个最大值，其中的最小那个就是重心了。</li><li>如何求答案：利用深度优先遍历，将每个点的“最大值”求出来，取min就是答案。</li><li>如何求删掉后点数最大：一分为二（子树：深搜返回；上方的连通块：n-下方-自己）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*树的重心*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">2</span>*N; <span class="comment">// 无向图</span></span><br><span class="line"><span class="type">int</span> h[N]; <span class="comment">// 邻接表存储树，有N个节点，需要N个头节点</span></span><br><span class="line"><span class="type">int</span> e[M]; <span class="comment">//存储元素</span></span><br><span class="line"><span class="type">int</span> ne[M]; <span class="comment">// 存储列表的next值</span></span><br><span class="line"><span class="type">int</span> idx; <span class="comment">// 单链表指针</span></span><br><span class="line"><span class="type">int</span> n; <span class="comment">// 一共n个节点</span></span><br><span class="line"><span class="type">int</span> ans = N ;<span class="comment">// 答案，表示重心所在的子连通块中的最大值</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">//记录节点是否被访问过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加从a指向b，其实就是从a链表中插入b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回以u为根的子树中节点的个数，包括u节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">// 存储，删掉这个节点后连通块的最大值</span></span><br><span class="line">    st[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">1</span>; <span class="comment">// 存储以u为节点的子树的结点数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u];i!=<span class="number">-1</span>;i=ne[i])&#123; <span class="comment">// 访问每一个节点</span></span><br><span class="line">        <span class="type">int</span> j = e[i]; </span><br><span class="line">        <span class="keyword">if</span>(!st[j])&#123; </span><br><span class="line">            <span class="type">int</span> s = <span class="built_in">dfs</span>(j); <span class="comment">// 子树个数</span></span><br><span class="line">            res = <span class="built_in">max</span>(res,s); <span class="comment">// 记录所谓的最大值</span></span><br><span class="line">            sum+=s; <span class="comment">// 记录子树个数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="built_in">max</span>(res,n-sum); <span class="comment">// 跟树上方的连通块比较</span></span><br><span class="line">    ans = <span class="built_in">min</span>(res,ans);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);<span class="comment">//初始化表示头节点都为空</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123; <span class="comment">// n-1条边</span></span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin &gt;&gt; a&gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>); <span class="comment">// 这里可以随意选择一个节点来搜</span></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><p>例题：图内点的层次<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx; <span class="comment">//模板化了已经</span></span><br><span class="line"><span class="type">int</span> d[N],q[N]; <span class="comment">// 用d表示距离，q数组模拟队列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;<span class="comment">//模板化</span></span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx]  = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh =<span class="number">0</span>,tt =<span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(hh &lt;=tt)&#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(d[j] == <span class="number">-1</span>)&#123; <span class="comment">// 没有遍历过</span></span><br><span class="line">                d[j] = d[t] + <span class="number">1</span>; <span class="comment">// 距离</span></span><br><span class="line">                q[++tt] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="有向图的拓扑序列"><a href="#有向图的拓扑序列" class="headerlink" title="有向图的拓扑序列"></a>有向图的拓扑序列</h1><ul><li>概念：对于图中的每条边(x,y)，x都出现在y的前面。即都是从前指向后。</li><li>可以证明：一个有向的无环图一定有拓扑序列。因此有向无环图也被称为拓扑图。</li><li>可以证明：一个有向无环图，一定至少存在一个度数为0的点。<ul><li>反证法：假设一个有向无环图有N个点，每个点都度数不是0，那么就可以一直向前追溯。当追溯到第N+1个点时，由于只有N个点，只能一个点是相同的，所以必然是有环的，假设不成立。</li></ul></li><li>入度：多少边指向自己。</li><li>出度：自己多少条边出去。</li><li>如何求拓扑序列？<ul><li>入度为0的点作为起点。（没有任何一点在入度前）</li><li>把入度为0的点入队。</li><li>宽搜，每次取队头t，枚举t的所有出边t-&gt;j，删掉t-&gt;j 则d[ j ]—;<ul><li>如果 d[ j ] = 0 , j入队</li></ul></li></ul></li></ul><p>题目描述：<br>给定一个 n 个点 m条边的有向图，点的编号是 1到 n，图中可能存在重边和自环。<br>请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出 −1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">拓扑排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"><span class="type">int</span> q[N],d[N]; <span class="comment">// d表示入度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>,tt =<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d[i] == <span class="number">0</span>) q[++tt] = i; <span class="comment">// 所有入度为0的点都入队。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)&#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            d[j]--;</span><br><span class="line">            <span class="keyword">if</span>(d[j] == <span class="number">0</span>) q[++tt] = j; <span class="comment">// 如果入度为0，入队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tt == n<span class="number">-1</span>; <span class="comment">// 判断是否全部都入队。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        d[b]++; <span class="comment">// 更新入度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">topsort</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础篇--Collection接口(2)</title>
      <link href="/posts/f3766ecd.html"/>
      <url>/posts/f3766ecd.html</url>
      
        <content type="html"><![CDATA[<div class="tip info"><p>前方高能，将涉及较多的底层源码和数据结构与算法</p></div><h1 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h1><ol><li>集合框架体系</li><li>Collection接口之List接口</li><li>Collection接口之Set接口</li><li>Map接口 &lt;==</li><li>Collections工具类 &lt;==</li></ol><h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><p>Map接口实现子类：Hashtable-Properties、HashMap-LinkedHashMap、TreeMap</p><p>Map接口的特点：</p><ul><li>Map和Collection并列存在，之间没什么关系。</li><li>Map用于保存具有映射关系的数据：键值对。可以是任意引用类型。</li><li>保存的key和value封装到HashMap$Node对象中</li><li>Map中key不允许重复，替换机制之前将Hash值讲过。如果重复用新值替换旧值。</li><li>key、value都可以为null，key为null只能是一个。key通常设置为String.</li><li>key和value存在单向一对一关系，类似于身份证。</li></ul><h2 id="Map常用方法"><a href="#Map常用方法" class="headerlink" title="Map常用方法"></a>Map常用方法</h2><p>put(key,value)：放入元素<br>remove(key)：删除<br>map.get(key)：获取值</p><h2 id="EntrySet、keySet、values与HashMap-Node的关系"><a href="#EntrySet、keySet、values与HashMap-Node的关系" class="headerlink" title="EntrySet、keySet、values与HashMap$Node的关系"></a>EntrySet、keySet、values与HashMap$Node的关系</h2><p>结论：</p><ul><li>键值对KV最终类型是：HashMap$Node内部类</li><li>为了方便程序员遍历，会创建EntrySet，存放Entry，一个Entry内的是KV，也就是EntrySet<code>&lt;Entry&lt;K,V&gt;&gt;</code></li><li>EntrySet的类型是Map.Entry，但是实际上存放的还是一个HashMap$Node。因为Node实现了Map.Entry接口。体现了多态特性。</li><li>好处：HashMap$Node对象存放到EntrySet过后，因为Map.Entry提供了重要的方法，getKey()和getValue()，所以遍历方便。</li><li>EntrySet中不是真的存放元素，而是指向了Node。</li></ul><div class="img-wrap"><div class="img-bg"><img class="img" src="ttps://s2.loli.net/2023/01/19/HoXpMzgG2CJIbuQ.png" alt="Entry"/></div><span class="image-caption">Entry</span></div><p>这一点在Map的遍历中可见一斑。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object obj : set)&#123;</span><br><span class="line">    Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) obj; <span class="comment">// 向下转型</span></span><br><span class="line">    sout(<span class="string">&quot;key = &quot;</span> + entry.getKey() + <span class="string">&quot;value = &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Map的遍历"><a href="#Map的遍历" class="headerlink" title="Map的遍历"></a>Map的遍历</h2><p>第一种方式：取出所有的Key，通过get取出value。<br>.keySet()方法：获取所有值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">keyset</span> <span class="operator">=</span> map.keySet();</span><br><span class="line"><span class="comment">//集合的遍历</span></span><br><span class="line"><span class="keyword">for</span>(Object key : keyset)&#123;</span><br><span class="line">    sout(key + <span class="string">&quot;-&quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里也可以用迭代器了</span></span><br></pre></td></tr></table></figure><p>第二种：用values取出所有值<br>containsKey()查找key是否存在<br>values：所有值的集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();</span><br><span class="line"><span class="comment">//集合的遍历</span></span><br><span class="line"><span class="keyword">for</span>(Object value : values)&#123;</span><br><span class="line">    sout(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种：通过EntrySet提供的getKey和getValue方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">entryset</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line"><span class="comment">//遍历取出每一个Entry</span></span><br><span class="line"><span class="keyword">for</span>(Object entry : entryset)&#123;</span><br><span class="line">    Map.<span class="type">Entry</span> <span class="variable">m</span> <span class="operator">=</span> (Map.Entry) entry;<span class="comment">//向下转型获得方法</span></span><br><span class="line">    sout(m.getKey() + <span class="string">&quot;- &quot;</span> + m.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础篇--Collection接口(1)</title>
      <link href="/posts/d85b3d0e.html"/>
      <url>/posts/d85b3d0e.html</url>
      
        <content type="html"><![CDATA[<div class="tip info"><p>前方高能，将涉及较多的底层源码和数据结构与算法</p></div><h1 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h1><ol><li>集合框架体系</li><li>Collection接口之List接口</li><li>Collection接口之Set接口</li><li>Map接口(下一篇博客)</li><li>Collections工具类(下一篇博客)</li></ol><h1 id="集合框架体系图"><a href="#集合框架体系图" class="headerlink" title="集合框架体系图"></a>集合框架体系图</h1><p>集合主要分为 <span class='p red'>单列集合</span>以及<span class='p red'>双列集合（KV）</span></p><p>Collection接口有两个重要的子接口：List接口和Set接口。其实现子类均为单列集合。<br>List下设：ArrayList、Vector、LinkedList<br>Set下设：HashSet、TreeSet<br>Map下设：HashMap(LinkedHashMap)、Hastable(Properties)、TreeMap</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://s2.loli.net/2023/01/18/tj8HwSFlG2yXERe.png" alt="集合框架体系图"/></div><span class="image-caption">集合框架体系图</span></div><h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><h2 id="Collection接口介绍"><a href="#Collection接口介绍" class="headerlink" title="Collection接口介绍"></a>Collection接口介绍</h2><ol><li>Collection的实现子类，可以存放多个元素，每个元素可以是Object。</li><li>有些Collection实现类可以存放重复元素，有些不可以。</li><li>存放顺序有序List、存放顺序无序为Set</li><li>没有直接实现子类，通过子接口List、Set实现。</li></ol><h2 id="Collection接口常见方法"><a href="#Collection接口常见方法" class="headerlink" title="Collection接口常见方法"></a>Collection接口常见方法</h2><p class='p red'>这里以ArrayList为例子</p><ul><li>添加：add(Object value)。如果是基本数据类型会自动装箱。</li><li>删除：<ul><li>remove(index)指定索引，返回删除的元素</li><li>remove(Object value)指定元素，返回是否成功</li></ul></li><li>元素是否存在：<span class='p blue'>contains(Object)</span></li><li>个数：size()</li><li>是否为空：isEmpty()</li><li>清空: clear()</li><li>添加多个元素：<span class='p blue'>addAll(Collection)参数是Collection，可以传入ArrayList</span></li><li>查找多个元素:<span class='p blue'>containsAll(Collection)参数是Collection，可以传入ArrayList</span></li><li>删除多个元素：<span class='p blue'>removeAll(Collection)参数是Collection，可以传入ArrayList</span></li></ul><h2 id="Collection-遍历方式"><a href="#Collection-遍历方式" class="headerlink" title="Collection 遍历方式"></a>Collection 遍历方式</h2><h3 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h3><p>Collection实现了父接口Iterable，实现了Collection的集合类都有一个iterator()方法，可以返回Iterator对象对元素遍历。<br>模板一般如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span>  <span class="operator">=</span> coll.iterator(); <span class="comment">// 得到迭代器</span></span><br><span class="line"><span class="keyword">while</span>( iterator.hasNext())&#123; <span class="comment">// **必须先判断有下一个元素，hasNext必须调用**</span></span><br><span class="line">sout(iterator.next()); <span class="comment">// next的作用：往下移动 + 将下移以后的集合位置上的元素返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当程序退出的时候，iterator指向最后一个元素。</span></span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>iterator只可遍历集合，本身不存在对象。</li><li>如果希望再次遍历，需要重置迭代器。iterator = col.interator();</li><li>快捷键：itit 或者Ctrl+J</li></ol><h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><p>简化版的iterator，底层就是iterator，所以只能遍历Collection和数组。<br>快捷键：大写i</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object obj : books)&#123; sout(obj);&#125;</span><br></pre></td></tr></table></figure><h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ol><li>List存放的元素有序，并且可以重复。</li><li>支持索引，从0开始。底层是数组。访问方式：list.get(index);</li><li>JDK API中List接口的实现类很多，不只是这里介绍的三种。</li></ol><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>底层由数组实现，基本等同Vector，但是<span class='p red'>ArrayList线程不安全但是效率高，建议单线程用，而多线程建议用Vector。</span></p><details class="folding-tag" blue><summary> 先说结论 </summary>              <div class='content'>              <ul><li>底层：ArrayList中维护的Object类型的数组elementData。</li><li>扩容机制：<ul><li>无参创建默认数组容量为0，第一次添加扩容成10。如果还需要扩容，每次为原来的1.5倍</li><li>有参构造初始为指定容量，以后按照1.5倍扩容。</li></ul></li></ul>              </div>            </details><details class="folding-tag" red><summary> 再看底层代码 </summary>              <div class='content'>              <p>分析List.add()如何走：</p><ol><li>走ensureCapacityInternal()，确认内部容量，然后再进行数组赋值elementData[size++]<ol><li>如果数组为空，给最小容量Math.max(DEFAULT,minCapacity);//DEFAULT就是10.</li><li>走ensureExplictCapacity()确认是否需要扩容<ol><li>modcount++;（防止多线程操作）</li><li>minCapacity - elementData.length &gt; 0 即数组大小不足，执行grow(minCapacity); 进行扩容</li></ol></li></ol></li><li>问题来了，核心的grow()方法如何扩容？<ol><li>old = 容量；new = old + old&gt;&gt;1; 也就是1.5倍了</li><li>首先是两个特判<ol><li>如果 new - min &lt; 0 这里是 0 - 10（用来处理第一次） new = min; 也就是说第一次扩容，扩容了10。</li><li>如果 new - MAX_ARRAY_SIZE(一个很大的常量) &gt; 0（处理容量太大）执行hugeCapacity方法</li></ol></li><li>最终执行 elementData = Arrays.copyOf(elementData,newCapacity);</li></ol></li></ol>              </div>            </details><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>底层也是Object数组，但是为线程同步。<br>扩容机制：无参默认10，满按2倍扩容。</p><details class="folding-tag" red><summary> Vector底层机制类似ArrayList </summary>              <div class='content'>              <p>分析List.add()如何走：</p><ol><li>modcount++;  执行ensureCapacityHelper();不够就执行grow()</li><li>grow()<ol><li>old = length;</li><li>new = old + ((capacityIncrement &gt; 0)? capacityIncrement : old)默认就是后者，就是两倍。capacityIncrement是为了方便代码的灵活性，自己自定义数组的扩容大小。</li><li>如果new - min &lt;0 执行new = min; 再执行max判断，最后执行copyof(vector,new);</li></ol></li></ol>              </div>            </details><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><ul><li>底层：双向链表 + 双端队列</li><li>可以添加任意元素</li><li>线程不安全！</li><li>与ArrayList相比，增删效率高，改查效率低。实际开发中多是查询业务，所以ArrayList用的多。</li></ul><details class="folding-tag" blue><summary> 先说结论 </summary>              <div class='content'>              <ul><li>底层维护了双向链表。</li><li>维护了两个属性：first、last指向首节点和尾节点。</li><li>每个Node节点维护了next、prev、item三个元素。</li><li>添加删除不是通过数组，所有效率不错。</li></ul>              </div>            </details><details class="folding-tag" red><summary> 再说底层 </summary>              <div class='content'>              <p>分析List.add()如何走：</p><ol><li>调用add()方法会默认执行linklast(e)。</li><li>linklast()内会new一个新节点，加到末尾。</li><li>如果是第一次，这个节点样子为两头为空。</li></ol><p>list.remove()分析：默认头删，除此之外还支持index和值</p><ol><li>remove() 进去直接调用 removeFirst()</li><li>removeFirst()内，如果空抛出异常，否则调用unlinkFirst()</li><li>unlinkFirst(f) 就是删除链表。<ol><li>取出元素方便返回。</li><li>next指向f的next</li><li>f的item为 null，next变null(help gc) first为next，next的prev为null</li></ol></li></ol>              </div>            </details><h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><ul><li>无序，添加和取出顺序不同。</li><li>不允许重复元素，最多只有一个null</li><li>可以用collection的方法</li><li>不能使用索引的方法遍历。</li></ul><h3 id="重磅！HashSet"><a href="#重磅！HashSet" class="headerlink" title="重磅！HashSet"></a>重磅！HashSet</h3><div class="tip warning"><p>前方高能，非战斗人员迅速撤离</p></div><ul><li>底层实际上是HashMap。</li><li>不保证元素是有序的，取决于hash后，再确定索引的结果。</li></ul><span class='p red'>经典面试题：下面加入了几个元素？</span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hashset = <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">hashset.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hsp&quot;</span>));</span><br><span class="line">hashset.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hsp&quot;</span>));</span><br><span class="line">System.out.println(hashset);</span><br></pre></td></tr></table></figure><p>答案：只加入了一个。分析：就要来看底层add()的机制了！</p><details class="folding-tag" blue><summary> HashSet底层--先说结论 </summary>              <div class='content'>              <p>底层是邻接表！</p><ol><li>HashSet底层是HashMap，HashMap的底层是—》数组 + 链表 + 红黑树</li><li>add()一个元素的时候顺序如下</li></ol><ul><li>先得到hash值—&gt;转成索引。</li><li>找到数据表table，看这个索引位置是否已经存放元素。<ul><li>如果没有，直接加入。</li></ul></li><li>如果有，调用equals方法。<ul><li>equals方法中（由程序员确定），看具体对象的重写。</li><li>如果相同，就放弃添加。</li><li>如果不相同，则添加到链表最后。</li></ul></li></ul><p>在JDK8中，如果一条链表的个数到达TREEFY_THRESHOLD(默认8)<br>并且table的大小&gt;=MIN_TREEFY_CAPACITY(64)就会将链表进行树化。<br>把链表转化为红 黑 树！</p>              </div>            </details><details class="folding-tag" red><summary> HashSet底层--再看底层代码 </summary>              <div class='content'>              <ol><li>add(e) 执行 return map.put(e,PRESENT) == null // PRESENT是hashset的一个final静态对象，是一个占位作用的Object对象。也就是说key是变化的，value是一个共享的PRESENT。</li><li>map.put(e,PRESENT)会执行：return putVal(hash(key),key,value,false,true);<ol><li>其中hash(Object key) — &gt; return (key==null)?0 : (h=key.hashcode())^(h&gt;&gt;&gt;16)  是计算哈希值的算法，可以尽量避免冲突。</li></ol></li><li>putVal(int hash, K key , V value, boolean onlyIfAbsent, boolean evict)<ol><li>其中resize()方法用于扩容！</li></ol></li></ol><p>下面请欣赏putVal的代码解析：<br>final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) {<br>    Node<K,V>[] tab; Node<K,V> p; int n, i; // 辅助变量,//table—放Node结点的数组，即邻接表<br>    //如果table为空或者大小为0，第一次扩容为16个空间。<br>    if ((tab = table) == null || (n = tab.length) == 0)<br>        n = (tab = resize()).length; //table这里就变成16的大小了<br>    //辅助变量p: 根据传入的key得到的hash值，去计算key应该存放到table表的哪个索引,这个位置的对象赋值给p<br>    //再判断p是否为空<br>    if ((p = tab[i = (n - 1) &amp; hash]) == null)<br>            tab[i] = newNode(hash, key, value, null);<br>            //，如果是空，表示没存放过数据。那么创建新结点(hash,key,value,null)存放hash只为了将来equals用<br>        else {<br>            //如果p不是空，比如第二次插入java这个字符串。<br>            Node<K,V> e; K k;<br>    //如果：当前索引位置对应的链表的【第一个元素】和准备添加的key的hash值一样<br>    //【并且】满足（准备加入的key 和 p指向的Node结点的key是同一个对象）.【或者】（p指向的Node结点的key的equals方法和准备加入的key比较后相同）<br>    //就：不能加入。<br>            if (p.hash == hash &amp;&amp;<br>                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))<br>                e = p;<br>    //特判一下，p是不是一颗红黑树。如果是一颗红黑树，就调用putTreeVal()方法进行添加。里面有大量红黑树算法<br>            else if (p instanceof TreeNode)<br>                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);<br>    //走到这里表示：和第一个结点不一样<br>    else {<br>        //遍历链表，。<br>        //依次和该链表的每一个元素比较后，都不相同，则加到链表最后。<br>        //如果有相同情况，直接break<br>        for (int binCount = 0; ; ++binCount) { // 死循环<br>            if ((e = p.next) == null) { // 不比较头节点<br>                p.next = newNode(hash, key, value, null);<br>            if(tab == null||(n=tab.length) &lt; MIN_TREEIFY_CAPACITY)      resize()<br>            //在把元素添加到链表后，立即判断该链表是否已经达到8点<br>            //如果达到，对当前链表进行树化，转成红黑树。<br>            //注意，在进行树化时，会判断table的长度是否小于64。小于64不会真的树化，但是会resize()对数据表扩容。<br>            if (binCount &gt;= TREEIFY_THRESHOLD - 1) //&gt;=7 // -1 for 1st<br>                treeifyBin(tab, hash);<br>            break;<br>        }<br>            if (e.hash == hash &amp;&amp;((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))<br>                break;<br>            p = e;<br>        }<br>    }<br>    if (e != null) { // existing mapping for key<br>        V oldValue = e.value;<br>        if (!onlyIfAbsent || oldValue == null)<br>            e.value = value;<br>        afterNodeAccess(e);<br>        return oldValue; // 不返回空，代表失败。<br>    }<br>}<br>        ++modCount;<br>    //扩容临界值，在resize内是0.75*capacity = 12<br>        if (++size &gt; threshold)<br>            resize();<br>    //hashMap 留给子类重新实现，本身为空方法<br>        afterNodeInsertion(evict);<br>        return null; // 返回空代表成功！如果返回一个对象，代表有东西存在<br>    }</p>              </div>            </details><p>总结：</p><ol><li>第一次添加时，table数组扩容16，临界值threshold是16*0.75=12</li><li>如果table到达临界值，就会扩容到原来的两倍，也就是32.</li><li>扩容机制：我现在凌晨在这里追底层代码，就是为了确认，当你重写hashcode使得某个对象加入到set中处于同一条链表，当链表节点超过8时，每加入一次会对表进行扩容。比如添加第9个数据，表会扩容到32，第10个就会64，然后添加第11个就会变成红黑树。</li><li>保证某类对象满足某些条件就无法加入hashmap：重写hashcode和equals方法。</li></ol><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><ol><li>属于HashSet的子类。</li><li>底层是LinkedHashMap，维护的是：数组 + 双链表。</li><li>根据hashcode决定元素存储位置，同时维护元素的次序，这使得元素看起来是按照插入顺序进行排序的。</li><li>不允许添加重复元素。</li></ol><p>底层细节：</p><ul><li>LinkedHashSet中维护一个哈希表 + 双向链表。在LinkedHashSet中有head和tail节点。</li><li>每一个节点，都有一个before|after属性，可以形成双链表。</li><li>在添加一个元素的时候<ul><li>先求哈希值，再求索引。</li><li>确定该元素在table中的位置，然后将这个节点添加到双向链表中。</li><li>tail.next = newElement;newElement.pre = tail; tail = newElement;</li></ul></li><li>遍历LinkedHashSet也能保证插入顺序和遍历顺序相同。</li></ul><p>底层结构：</p><ul><li>table第一次添加初始化为16.</li><li>table的类型是内部类，HashMap$Node</li><li>节点的类型是LinkedHashMap$Entry,不是Node</li><li>这么存放体现了多态现象。—Entry继承了HashMap.Node</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础篇--OOP(3)</title>
      <link href="/posts/c9252d6.html"/>
      <url>/posts/c9252d6.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java阶段1—Java基础篇—-gt-OOP-3"><a href="#Java阶段1—Java基础篇—-gt-OOP-3" class="headerlink" title="Java阶段1—Java基础篇—&gt;OOP(3)"></a>Java阶段1—Java基础篇—&gt;OOP(3)</h1><h2 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h2><ol><li>static:类变量和类方法</li><li>理解main方法语法</li><li><strong>CodeBlock代码块</strong></li><li>设计模式—单例模式</li><li>final关键字</li><li>abstract:抽象类</li><li><strong>interface:接口</strong></li><li><strong>InnerClass内部类</strong></li></ol><h2 id="static-类变量和类方法"><a href="#static-类变量和类方法" class="headerlink" title="static:类变量和类方法"></a>static:类变量和类方法</h2><h3 id="类变量定义"><a href="#类变量定义" class="headerlink" title="类变量定义"></a>类变量定义</h3><p>类变量，又叫静态变量，最大特点是会被所有对象实例共享。<br>静态变量在类加载的时候就生成。</p><h3 id="类变量的内存布局"><a href="#类变量的内存布局" class="headerlink" title="类变量的内存布局"></a>类变量的内存布局</h3><p>JDK8以前放在方法区，JDK8以后放在堆内，通过反射机制加载class对象。</p><h3 id="类变量的注意事项"><a href="#类变量的注意事项" class="headerlink" title="类变量的注意事项"></a>类变量的注意事项</h3><ol><li>定义推荐顺序：public static int a = 10;</li><li>使用：类名.方法</li><li>重点：类变量在类加载的时候就初始化，生命周期是随着类的加载而开始，随着类的消亡而消亡。</li></ol><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>使用场景：不需要实例化对象，用于工具类使用。<br>例如：Math类、Array类、Collections类<br>注意事项：</p><ol><li>类方法随着类的加载而加载。</li><li>不允许使用与对象有关的关键字：super 和 this。</li><li><strong>类方法中只能访问静态变量和静态方法</strong>。</li><li>普通的成员方法可以访问普通属性和方法，也可以访问静态的属性和方法。</li></ol><h2 id="理解Main方法的语法"><a href="#理解Main方法的语法" class="headerlink" title="理解Main方法的语法"></a>理解Main方法的语法</h2><h3 id="main方法的机制"><a href="#main方法的机制" class="headerlink" title="main方法的机制"></a>main方法的机制</h3><ol><li>public: main方法用JVM调用。</li><li>static: JVM在执行main方法时，没必要创建对象。</li><li>String[] args: 该方法接受String数组参数，该数组中保存了执行java命令时候传递给所运行类的参数。</li></ol><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><ol><li>作为静态方法，main方法中可以直接调用main所在类的静态方法和静态属性。</li><li>作为静态方法，main方法同理不能访问类中非静态成员，必须实例化对象。</li></ol><h2 id="❤️‍🔥CodeBlock"><a href="#❤️‍🔥CodeBlock" class="headerlink" title="❤️‍🔥CodeBlock"></a>❤️‍🔥CodeBlock</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>属于类的成员，将逻辑语句封装到{}中。<br>没有方法名、返回、参数，无法显式调用，而是加载类时隐式调用。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>修饰符可选，只能用static。以此分为静态代码块和普通代码块。</p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ol><li>对构造器的补充机制，可以做初始化操作。</li><li>如果多个构造器有重复代码的话，可以抽取到块中，提高复用。</li><li>调用机制：<strong>先代码块后调用构造器</strong>。—见下方介绍</li></ol><h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h3><ol><li>静态代码块随着类加载而执行，<strong>只会执行一次</strong>！如果是<strong>普通代码块，每创建一个对象就执行</strong>。如果只使用类的静态成员，普通代码块不会被调用。</li><li>❤️‍🔥<strong>类加载的时机</strong>：<ol><li>new一个对象时。</li><li>new一个子类时，父类也会被加载。而且父类先被加载！</li><li>使用类的静态成员时。</li></ol></li><li>❤️‍🔥创建一个对象时，<strong>类的调用顺序</strong>是：<ol><li>调用静态代码块和静态属性。（静态代码块和静态属性<strong>初始化</strong>调用优先级同，看定义顺序）</li><li>调用普通代码块和普通属性。（普通代码块和普通属性<strong>初始化</strong>调用优先级同，看定义顺序）</li><li>调用构造器。</li></ol></li><li>构造器前面隐含了两句话: super() 和普通代码块。</li><li>❤️‍🔥❤️‍🔥创建一个子类对象时，各内容的调用顺序：<ol><li>父类的静态代码块和静态属性初始化。</li><li>子类的静态代码块和静态属性初始化。</li><li>父类的普通代码块和普通属性初始化。</li><li>父类的构造器。</li><li>子类的普通代码块和普通属性初始化。</li><li>子类的构造器。</li></ol></li><li>静态代码块只能调用静态成员，普通代码块能调用任意成员。</li></ol><h2 id="设计模式—单例设计模式"><a href="#设计模式—单例设计模式" class="headerlink" title="设计模式—单例设计模式"></a>设计模式—单例设计模式</h2><h3 id="什么是设计模式？"><a href="#什么是设计模式？" class="headerlink" title="什么是设计模式？"></a>什么是设计模式？</h3><p>设计模式是在大量实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式就像是经典的棋谱，不同的棋局，我们用不同的棋谱，免去我们自己思考和摸索。</p><h3 id="什么单例模式？"><a href="#什么单例模式？" class="headerlink" title="什么单例模式？"></a>什么单例模式？</h3><p>采取一定的方法保证整个软件系统中，对<strong>某个类只能存在一个对象实例</strong>，并且该类只提供一个取得其对象实例的方法。<br>两种方式：饿汉模式 和 懒汉模式</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><ol><li>构造器私有化。防止new一个对象。</li><li>类内部创建对象。</li><li>向外提供静态的公共方法。</li><li>代码实现。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GirlFriend</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">GirlFriend</span> <span class="variable">girlfriend</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GirlFriend</span>(<span class="string">&quot;Sonia&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GirlFriend</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GirlFriend <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> girlfriend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉模式在类加载时对象就创建了，有可能不需要用到这个对象的，但是已经创建了。</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><ol><li>构造器私有化。</li><li>定义一个static的对象。但是<strong>没有new!</strong></li><li>提供接口返回对象。</li><li>唯一区别：只有当用户调用接口时，才会返回对象。如果再次调用会返回上次的对象。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Cat cat; <span class="comment">// 没有new！</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Cat</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Cat <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cat == <span class="literal">null</span>) cat = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="饿汉式-VS-懒汉式"><a href="#饿汉式-VS-懒汉式" class="headerlink" title="饿汉式 VS 懒汉式"></a>饿汉式 VS 懒汉式</h3><ol><li>最大区别：创建对象时机不同，饿汉在类加载就创建，懒汉在使用才创建。</li><li>安全问题：饿汉式不存在线程安全；懒汉式存在线程安全问题。</li><li>资源：饿汉式存在浪费资源的可能。懒汉式不存在这个问题。</li><li>javaSE标准类中，RunTime就使用了饿汉模式。</li></ol><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>修饰：</p><ol><li>类：不希望类被继承。</li><li>方法：不希望父类的某个方法被子类重写。</li><li>属性和局部变量：不希望被修改。</li></ol><h3 id="使用细节-1"><a href="#使用细节-1" class="headerlink" title="使用细节"></a>使用细节</h3><ol><li>常量一般用全大写。</li><li>final修饰时候必须初始化。初始化位置可以是：<ol><li>定义时候直接赋值。</li><li>构造器中。</li><li>代码块中。</li></ol></li><li>final修饰静态，初始化位置要么是直接赋值要么是静态代码块中。</li><li>final方法虽然不能重写，但是可以继承。</li><li>一般来讲，如果final修饰了类，就没必要修饰方法了。既然都无法继承了，还怕被重写吗？</li><li>final不能修饰构造器。</li><li><strong>final和static往往搭配使用，效率更高，不会导致类加载。</strong></li></ol><p>这里有一个例子：在这里final和static一起用，加载B类，也就不会输出静态代码块的内容。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">999</span>;</span><br><span class="line">    staic&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is B&#x27;s static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下为main方法内</span></span><br><span class="line">System.out.println(B.num);</span><br></pre></td></tr></table></figure></p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>abstract关键字，抽象类价值在于设计，让子类重写实现抽象类。</p><h3 id="细节-1"><a href="#细节-1" class="headerlink" title="细节"></a>细节</h3><ol><li>抽象类不可以被实例化。</li><li>一旦写了抽象方法，这个类就是抽象类。但抽象类可以没有抽象方法。</li><li>abstract只能修饰类和方法，不能修饰其它。 </li><li>抽象类本质还是类，可以拥有非抽象方法，构造器，静态属性。</li><li>抽象方法不能有主体。</li><li>如果一个类继承了抽象类，那就必须实现抽象类内所有抽象方法。除非自己也是抽象类。</li><li><strong>抽象方法不能用private static final修饰。</strong><ol><li>private:私有了还重写个P。</li><li>static: 你都没主体，那外部直接调用static方法实现个P。</li><li>final: 无法继承还抽象个P。</li></ol></li></ol><h3 id="设计模式—模板设计模式（抽象类最佳实践）"><a href="#设计模式—模板设计模式（抽象类最佳实践）" class="headerlink" title="设计模式—模板设计模式（抽象类最佳实践）"></a>设计模式—模板设计模式（抽象类最佳实践）</h3><ol><li>设计一个抽象类Template<ol><li>编写calculateTime()计算某段代码的耗时时间。</li><li>编写抽象方法job()</li></ol></li><li>编写子类Sub继承抽象类并实现job方法。</li><li>编写一个测试类进行测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculateTiem</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        job(); <span class="comment">// 动态绑定机制，不同子类调用时，执行的是不同的job</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行时间 &quot;</span> + (end - start));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AA</span> <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">800000</span>; i++) &#123;</span><br><span class="line">            num+=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTemplate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AA</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA</span>();</span><br><span class="line">        aa.calculateTime(); <span class="comment">// 这里还是需要有良好的OOP基础，尤其是对多态动态绑定机制的理解</span></span><br><span class="line">        <span class="type">BB</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line">        bb.calculateTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="❤️‍🔥Interface"><a href="#❤️‍🔥Interface" class="headerlink" title="❤️‍🔥Interface"></a>❤️‍🔥Interface</h2><p>给出一些没有实现的方法，封装到一起，当某类要使用再具体实现。<br>语法：interface 接口名{属性 方法} 方法可以为抽象、默认、静态</p><ul><li>jdk7.0前，接口中所有方法都是抽象方法</li><li>jdk8.0后，可以有静态方法和默认方法。<br>实现：关键字implements</li></ul><h3 id="应用场景—控制软件的质量和规范"><a href="#应用场景—控制软件的质量和规范" class="headerlink" title="应用场景—控制软件的质量和规范"></a>应用场景—控制软件的质量和规范</h3><p>以连接三个不同的数据库为例，用接口可以实现方法名的统一。</p><h3 id="细节-2"><a href="#细节-2" class="headerlink" title="细节"></a>细节</h3><ol><li>与抽象类相同，无法实例化。</li><li>与类相同，接口的修饰符只能是public 或者 无修饰。</li><li>所有方法都是public abstract 所以可以不用写。</li><li>普通类如果实现接口，必须实现接口的所有方法。快捷键：alt + enter</li><li>抽象类实现接口，可以不实现方法。</li><li>不同于继承，一个类可以实现多个接口。</li><li><strong>接口中的属性，只能是final，而且是public static final修饰符。</strong></li><li>因此，接口属性的访问方式：接口名.属性名</li><li>一个接口不能继承其它类，但可以继承其它接口。</li></ol><h3 id="接口与继承的比较"><a href="#接口与继承的比较" class="headerlink" title="接口与继承的比较"></a>接口与继承的比较</h3><ol><li>解决问题不同：<ul><li>继承解决：代码复用性和可维护性。</li><li>接口解决：设计和规范。</li></ul></li><li>灵活性：接口比继承更灵活。<ul><li>继承：is a 的关系。</li><li>接口：like a 的关系</li></ul></li><li>接口在一定程度上实现代码解耦。<br>（接口规范性+配合动态绑定机制，实现解耦。）</li></ol><h3 id="❤️‍🔥接口的多态特性"><a href="#❤️‍🔥接口的多态特性" class="headerlink" title="❤️‍🔥接口的多态特性"></a>❤️‍🔥接口的多态特性</h3><ol><li>多态参数：接受一个接口参数，可以传入其他具体的类。形参是接口，实参是类。</li><li>多态数组：一个接口类型数组，每一个位置可以存放一个不同的类对象，遍历的时候可以执行各自的特有方法和实现了接口的公有方法。</li><li>接口存在多态传递现象：IG继承了IH，teacher实现了IG，相当于实现了IH。</li></ol><h2 id="❤️‍🔥❤️‍🔥❤️‍🔥内部类"><a href="#❤️‍🔥❤️‍🔥❤️‍🔥内部类" class="headerlink" title="❤️‍🔥❤️‍🔥❤️‍🔥内部类"></a>❤️‍🔥❤️‍🔥❤️‍🔥内部类</h2><p>类的五大成员：属性、方法、构造器、代码块、内部类。<br>内部类最大特点：直接访问外部类私有属性，体现类和类的包含关系。<br>分类：</p><ul><li>外部类的方法内<ul><li>局部内部类</li><li>❤️‍🔥❤️‍🔥❤️‍🔥匿名内部类</li></ul></li><li>外部类位置<ul><li>成员内部类</li><li>静态内部类</li></ul></li></ul><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>定义在外部类的局部位置，比如方法和代码块中，并且有类名。</p><h4 id="细节-3"><a href="#细节-3" class="headerlink" title="细节"></a>细节</h4><ol><li>能直接访问外部类成员，包括私有。</li><li>地位：局部变量。无法添加访问修饰符。但是可以final。</li><li>作用域：代码块和方法。</li><li>访问：<ol><li>外部类（作用域内） 访问 局部内部类：new对象。</li><li>局部内部类 访问 外部类：直接访问。</li><li>外部其它类 无法访问 局部内部类。</li></ol></li><li>命名：<ol><li>如果外部类和局部内部类重名，就近原则。 </li><li>访问外部类：外部类名.this.成员</li><li>解读：外部类名.this就是外部类的实例对象。</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> n1= <span class="number">200</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> f1&#123;</span><br><span class="line">                <span class="comment">//方法体</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.f1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="❤️‍🔥❤️‍🔥❤️‍🔥匿名内部类"><a href="#❤️‍🔥❤️‍🔥❤️‍🔥匿名内部类" class="headerlink" title="❤️‍🔥❤️‍🔥❤️‍🔥匿名内部类"></a>❤️‍🔥❤️‍🔥❤️‍🔥匿名内部类</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ol><li>本质是类。</li><li>是内部类。</li><li>没有名字：表面上没有，其实系统分配了名字并隐藏了。</li><li>❤️‍🔥<strong>同时是一个对象。</strong></li></ol><p>语法：<br>new 类/接口(参数列表)<strong>{//类体};</strong></p><h4 id="基于接口的匿名内部类—匿名对象类实现了接口"><a href="#基于接口的匿名内部类—匿名对象类实现了接口" class="headerlink" title="基于接口的匿名内部类—匿名对象类实现了接口"></a>基于接口的匿名内部类—匿名对象类实现了接口</h4><ol><li>需求：使用IA接口并创建对象，但是这个对象只用一次，专门写个类来实现接口不划算。</li><li>编译类型：接口类型IA</li><li>运行类型：匿名内部类—系统自动命名（可以用.getClass()查看）</li><li>JDK底层在创建匿名内部类后就立即<strong>创建了一个实例！</strong></li><li>匿名内部类使用一次就不再使用了，但是引用可以反复使用。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">IA</span> <span class="variable">tiger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IA</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;tiger is crying.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        tiger.cry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于类的匿名内部类—匿名对象类继承了父类"><a href="#基于类的匿名内部类—匿名对象类继承了父类" class="headerlink" title="基于类的匿名内部类—匿名对象类继承了父类"></a>基于类的匿名内部类—匿名对象类继承了父类</h4><ol><li>编译类型：父类</li><li>运行类型：匿名对象类</li><li>参数列表会拆传给父类的构造器。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is father&#x27;s constructor,and I receive  &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">father</span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Override father&#x27;s test&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        father.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于抽象类的匿名内部类—必须重写方法"><a href="#基于抽象类的匿名内部类—必须重写方法" class="headerlink" title="基于抽象类的匿名内部类—必须重写方法"></a>基于抽象类的匿名内部类—必须重写方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类最佳实践：做实参直接传递"><a href="#匿名内部类最佳实践：做实参直接传递" class="headerlink" title="匿名内部类最佳实践：做实参直接传递"></a>匿名内部类最佳实践：做实参直接传递</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cagur.innerclass;</span><br><span class="line"><span class="keyword">import</span> com.cagur.abstract_.AA;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClassExercise01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 2023/1/6 当作实参直接传递，简洁高效</span></span><br><span class="line">        <span class="comment">//如果我们传入一个匿名内部类</span></span><br><span class="line">        f1(<span class="keyword">new</span> <span class="title class_">IL</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;这是十分简洁的匿名内部类的show方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(IL il)</span>&#123;</span><br><span class="line">        il.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IL</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>定义在外部类成员位置，并且没有static修饰。<br>介绍：</p><ol><li>同样的，也可以直接访问外部类成员。</li><li>地址是成员：可以添加修饰符。</li><li>调用方式：在外部类成员方法中new一个内部类对象，再调用内部类对象的方法。 </li><li>访问：<ol><li>内 访问 外： 直接</li><li>外 访问 内：new</li><li>外部其它类 访问 成员内部类：<ol><li>Outer.Inner inner = outer.new Inner();</li><li>Outer.Inner inner = outer.getInnerInstance();</li><li>Outer.Inner inner = new Outer.new Inner();</li></ol></li></ol></li><li>外部类和内部类重名—就近原则。想访问外部类：外部类名.this.成员</li></ol><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>定义在外部类成员位置，用static修饰。<br>使用：</p><ol><li>可以直接访问外部类所有静态成员，但是无法访问非静态。</li><li>可以添加四种修饰符。</li><li>访问：<ol><li>内 访问 外： 直接</li><li>外 访问 内：类名.成员</li><li>外部其类 访问 静态内部类<ol><li>Outer.Inner inner = new Outer.Inner();</li><li>Outer.Inner inner = outer.getInnerInstance();</li><li>Outer.Inner inner = Outer.getInnerInstance();//因为是静态的</li></ol></li></ol></li><li>重名仍然就近原则，想访问外部类直接：外部类名.成员。</li></ol><blockquote><p>❤️‍🔥❤️‍🔥由此，Java基础的OOP阶段终于完结撒花啦！❤️‍🔥❤️‍🔥</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础篇--OOP(2)</title>
      <link href="/posts/15896397.html"/>
      <url>/posts/15896397.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java阶段1—Java基础篇—-gt-OOP-2"><a href="#Java阶段1—Java基础篇—-gt-OOP-2" class="headerlink" title="Java阶段1—Java基础篇—&gt;OOP(2)"></a>Java阶段1—Java基础篇—&gt;OOP(2)</h1><h2 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h2><ol><li>IDEA快捷键</li><li>Package:包</li><li>访问修饰符</li><li>OOP三大特性之封装</li><li>OOP三大特性之继承</li><li>OOP三大特性之多态</li><li>super关键字</li><li>Overwrite</li><li>Object类</li><li>断点调试</li></ol><h2 id="IDEA快捷键"><a href="#IDEA快捷键" class="headerlink" title="IDEA快捷键"></a>IDEA快捷键</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">删除当前行: CTRL + Y</span><br><span class="line">复制当前行并粘贴: CTRL + D</span><br><span class="line">补全代码行: ALT + /</span><br><span class="line">*导入该行需要的类: ALT + ENTER</span><br><span class="line">快速格式化代码: CTRL + ALT + L</span><br><span class="line">运行: SHIFT + F5</span><br><span class="line">*生成构造器等: CTRL + ALT + INSERT</span><br><span class="line">*查看类的层级关系: CTRL + H</span><br><span class="line">*将光标放在一个方法上，输入 CTRL + B可以定位到具体类。</span><br><span class="line">自动分配变量名\for语句等模板：.var .fori</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>作用:</p><ol><li>区分相同名字的类</li><li>当类很多时，可以很好管理类。</li><li>控制访问范围。</li></ol><p>本质:创建不同的文件夹保存类文件。<br>解释:在com.cagur.a com.cagur.b中都存在Person类，如果在另外一个文件中要使用Person类，就要import 如果带上包名就不用import。但是只能有一个是不带包名的。</p><h3 id="包的命名规范"><a href="#包的命名规范" class="headerlink" title="包的命名规范"></a>包的命名规范</h3><p>小写字母 + 圆点<br>一般为com.公司名.项目名.业务模块名</p><h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h3><ul><li>import java.util.Scanner 只引入这一个类<ul><li>import java.util.* 表示引入这个包下所有类</li><li>建议：需要使用哪个类就导入哪个类即可，不要使用*</li></ul></li><li>package放在类最上面用来打包，一个类最多有一个package，import放package下</li></ul><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><div class="table-container"><table><thead><tr><th style="text-align:center">访问控制修饰符</th><th style="text-align:center">同类</th><th style="text-align:center">同包</th><th style="text-align:center">子类</th><th style="text-align:center">不同包</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:center">🆗</td><td style="text-align:center">🆗</td><td style="text-align:center">🆗</td><td style="text-align:center">🆗</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">🆗</td><td style="text-align:center">🆗</td><td style="text-align:center">🆗</td><td style="text-align:center">❌</td></tr><tr><td style="text-align:center">无修饰</td><td style="text-align:center">🆗</td><td style="text-align:center">🆗</td><td style="text-align:center">❌</td><td style="text-align:center">❌</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">🆗</td><td style="text-align:center">❌</td><td style="text-align:center">❌</td><td style="text-align:center">❌</td></tr></tbody></table></div><p>同一个类中，无论什么访问权限都能自由访问。<br>同一个包中，除了private其它都能访问。</p><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><ol><li>修饰符支持修饰类的属性、成员方法和类。</li><li>类只能用无修饰和public来修饰。</li></ol><h2 id="Encapsulation-封装"><a href="#Encapsulation-封装" class="headerlink" title="Encapsulation 封装"></a>Encapsulation 封装</h2><p>定义：数据被保护在内部，隐藏实现细节，只有通过调用提供的方法才能访问。<br>好处：可以对传入的数据进行验证。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>将属性设为private</li><li>提供public的set方法，用于判断并赋值。—加入数据验证的业务逻辑。</li><li>提供public的get方法，用于获取属性值。—加入权限判断的业务逻辑。</li></ol><p>set方法写在构造器中，仍然可以进行验证数据。</p><h2 id="Extend-继承"><a href="#Extend-继承" class="headerlink" title="Extend 继承"></a>Extend 继承</h2><p>好处：提高了代码复用性、代码扩展性和维护性。</p><h3 id="继承的细节"><a href="#继承的细节" class="headerlink" title="继承的细节"></a>继承的细节</h3><ol><li>继承是全继承。子类继承了父类所有成员，但是private的成员不能直接访问。除非通过父类提供的公共方法访问。</li><li>子类必须调用父类构造器。子类构造器隐藏了: super(); 即调用默认调用父类的无参构造。</li><li><strong>如果父类不提供无参构造器，则必须在子类构造器中用super指定父类的哪个构造器完成对父类的初始化工作！</strong></li><li>super必须放在子类构造器的第一行！</li><li>super() 和 this() 都只能放构造器第一行，因此不能共存于同一个构造器。</li><li>Object是所有类的基类。</li><li>父类构造器的调用不限于直接父类，将一直向上追溯到Object</li><li>单继承机制：子类最多继承一个父类。</li><li>不能滥用继承，必须满足 is a 的关系</li></ol><h3 id="继承的本质"><a href="#继承的本质" class="headerlink" title="继承的本质"></a>继承的本质</h3><p>建立一个查找关系！<br>方法区的加载顺序：从父到子。<br><strong>访问子类方法时候的查找顺序:</strong></p><ol><li>首先看子类是否有该属性。如果有且权限允许，就访问。</li><li>如果子类没有，就看父类是否有这个属性且权限允许，有就访问。</li><li>按照2的逻辑一直找到object</li><li>如果都没有就不行。如果找到其中一步但是访问权限为private，不会继续找，报错。</li></ol><h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>super代表父类引用，用于访问</p>]]></content>
      
      
      <categories>
          
          <category> JAVA后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础篇--OOP(1)</title>
      <link href="/posts/3ea43054.html"/>
      <url>/posts/3ea43054.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java阶段1—Java基础篇—-gt-OOP-1"><a href="#Java阶段1—Java基础篇—-gt-OOP-1" class="headerlink" title="Java阶段1—Java基础篇—&gt;OOP(1)"></a>Java阶段1—Java基础篇—&gt;OOP(1)</h1><h2 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h2><ol><li>对象在内存的简单布局</li><li>Field:属性\成员变量\字段</li><li>Method:成员方法</li><li>Overload:重载</li><li>VarParameter:可变参数</li><li>Scope:作用域</li><li>Constructor:构造器</li><li>this关键字</li></ol><h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><p>栈区：存放局部变量。<br>堆区：存放对象。<br>方法区：常量池（存储字符串常量）、加载类信息（属性 + 行为）</p><h2 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h2><h3 id="对象分配机制"><a href="#对象分配机制" class="headerlink" title="对象分配机制"></a>对象分配机制</h3><p>引用类型赋值。Person p1= new Person(); p2 = p1;实际上指向同一块堆区地址。</p><h3 id="Java创建类流程"><a href="#Java创建类流程" class="headerlink" title="Java创建类流程"></a>Java创建类流程</h3><ol><li>加载类信息(属性和方法)</li><li>堆区分配空间，进行默认初始化</li><li>把地址赋值给引用</li><li>进行指定属性初始化</li></ol><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><h4 id="传参机制"><a href="#传参机制" class="headerlink" title="传参机制"></a>传参机制</h4><p>基本数据类型：值传递;   引用类型:传地址;</p><h4 id="克隆对象"><a href="#克隆对象" class="headerlink" title="克隆对象"></a>克隆对象</h4><p>传入一个对象，返回另一个成员相同但地址独立的对象。<br>在方法内new一个，进行属性赋值即可。</p><h2 id="Overload"><a href="#Overload" class="headerlink" title="Overload"></a>Overload</h2><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><p>概念：<strong>同一个类</strong>中，多个<strong>同名方法</strong>存在。这样做减少了起名麻烦、方便接口编程。<br>相同：方法名<br>不同：形参列表(形参<strong>类型</strong>、形参<strong>个数</strong>、形参<strong>顺序</strong>)<br>无要求：返回类型</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>sout可以输出不同类型的数据。</p><h2 id="VarParameter"><a href="#VarParameter" class="headerlink" title="VarParameter"></a>VarParameter</h2><p>概念：<strong>同一个类</strong>中多个<strong>同名同功能</strong>但是<strong>参数个数不同</strong>的方法。<br>注意事项：</p><ol><li>参数个数：可变参数的实参可为0个到任意多个。</li><li>本质：数组。因此可变参数实参可以是数组！</li><li>位置：可变参数可以和普通类型参数放在形参列表后，但是必须保证可变参数在最后。</li><li>一个形参列表只可以有一个可变参数。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Method</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>... nums)</span>&#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h2><ol><li>生命周期：成员变量（全局变量）-跟随类的创建和死亡。局部变量-伴随代码块执行而创建和死亡。</li><li>作用域：全局变量在本类用或对象在其它类调用;局部变量只能在本类某方法中用。</li><li>修饰符：全局变量可修饰符，局部变量无修饰符。</li></ol><h2 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h2><p>介绍：用于完成对新对象初始化的特殊类方法，无返回值，类名和方法名同，由系统调用。</p><ol><li>构造器支持重载。</li><li>构造器语法规则：跟类名相同，无返回值。</li><li>系统在创建对象时自动调用。</li><li>若不写，系统自动生成默认无参构造器。（反编译:javap）</li><li><strong>一旦定义自己有参构造器，将覆盖系统默认无参构造器，除非显式声明。</strong></li></ol><h4 id="对象创建流程再分析"><a href="#对象创建流程再分析" class="headerlink" title="对象创建流程再分析"></a>对象创建流程再分析</h4><ol><li>方法加载类信息。堆区开空间。</li><li>进行默认初始化：null\0。</li><li>进行显式初始化：90、abc…</li><li>执行构造器。</li><li>将对象的的引用返回给变量</li></ol><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><ol><li>this用来访问本类的属性、构造器、方法。</li><li>this用于区分当前类的属性和局部变量。</li><li>用this访问构造器只能<strong>在构造器</strong>中使用，并且放在<strong>第一条</strong>语句！</li><li>this不能在类的外部使用，只能在类定义的方法中使用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JAVA后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-KMP、Trie树、并查集、堆</title>
      <link href="/posts/d0754ed5.html"/>
      <url>/posts/d0754ed5.html</url>
      
        <content type="html"><![CDATA[<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h2 id="题目引入"><a href="#题目引入" class="headerlink" title="题目引入"></a>题目引入</h2><p>给字符串S，模式串P，只包含英文字母和数字，P作为S的子串多次出现。<br>求P在S中所有出现位置的起始下标。</p><h2 id="暴力做法？"><a href="#暴力做法？" class="headerlink" title="暴力做法？"></a>暴力做法？</h2><p>每次匹配失败，只向后移动一位。<br>问题：有很多信息没有被利用，有被优化的空间。<br><strong>思考</strong>：最少移动多少使得【前缀】和【后缀】相等。<br>由于前缀和后缀只与<strong>匹配串</strong>有关，因此思考能否<strong>预处理</strong>出【最长的后缀】且与前缀相等。*</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>s[] 模式长串    p[]模板串<br>next[i]=j;表示；以i为终点的后缀 和 从1开始的前缀长度相等且最长，长度为j<br>当s[i]!=p[j+1]时候，需要移动next[j]的距离。<br>核心思想：next数组—退一步海阔天空！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//给大脑一个理解的时间，隔了很久之后重新看KMP突然感觉理解更深入了。</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>,M = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> p[N],s[M];</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p+<span class="number">1</span> &gt;&gt; m &gt;&gt; s+<span class="number">1</span>; <span class="comment">// KMP下标从1开始</span></span><br><span class="line">    <span class="comment">//求next数组过程--也是退而求其次不断地 j= ne[j]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;i++)&#123; <span class="comment">// ne[1] = 0</span></span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; p[i]!=p[j+<span class="number">1</span>]) j =ne[j]; <span class="comment">//不匹配，后退</span></span><br><span class="line">        <span class="keyword">if</span>(p[i] == p[j+<span class="number">1</span>]) j++; <span class="comment">//匹配成功，向下走</span></span><br><span class="line">        ne[i] = j; <span class="comment">// 记录next数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//KMP匹配过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=m;i++)&#123;  <span class="comment">//试图与s[i]匹配的是p[j+1]</span></span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; s[i]!=p[j+<span class="number">1</span>])&#123; <span class="comment">// j没有退回起点 并且 匹配失败</span></span><br><span class="line">            j=ne[j]; <span class="comment">//移动到next[j]的位置。理解：看ne[j]的含义。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i]== p[j+<span class="number">1</span>]) j++; <span class="comment">// KMP思想：j每次如果无法匹配就退1步，如果可以匹配就继续走。</span></span><br><span class="line">        <span class="keyword">if</span>( j == n)&#123;</span><br><span class="line">            <span class="comment">//匹配成功</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i-n+<span class="number">1</span> <span class="number">-1</span>); <span class="comment">//  向下走</span></span><br><span class="line">            j = ne[j];<span class="comment">// 匹配成功后，</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h1><p><strong>Trie树主要用于：快速存储和查找字符串集合</strong></p><h2 id="题目引入-1"><a href="#题目引入-1" class="headerlink" title="题目引入"></a>题目引入</h2><p>维护字符串集合，支持插入字符串、询问字符串在集合中出现了多少次。</p><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><p><strong>比较精妙的一点是idx的运用，跟链表类似！</strong><br>son[N][26] 存子节点;题目是26个字母的话，子节点最多就只有26条边<br>cnt[N] 存以当前结尾的单词的个数<br>操作：存储insert(char[])    查询query(char[])</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>]; <span class="comment">// 每个节点最多向外连接26条边，存每个节点的儿子</span></span><br><span class="line"><span class="type">int</span> cnt[N]; <span class="comment">//存以当前结尾的单词的个数</span></span><br><span class="line"><span class="type">int</span> idx;<span class="comment">//当前节点。 注意：下标是0的点是根节点和空节点</span></span><br><span class="line"><span class="comment">//存储操作，即插入操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;str[i];i++)&#123;<span class="comment">//字符串结尾是0</span></span><br><span class="line">        <span class="comment">//对于字符串上的每一个字母，如果当前节点不存在就创建节点</span></span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u] = ++idx;<span class="comment">//不存在则创建节点</span></span><br><span class="line">        p = son[p][u]; <span class="comment">// 往下走</span></span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++; <span class="comment">// 以这个点结尾的字符串个数多1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> str[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;str[i];i++)&#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 不存在</span></span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><ul><li>支持操作：合并两个集合；询问两个元素是否在同一个集合中。</li><li>思考：暴力做法？<ul><li>belong[x] 存储x属于哪个集合</li><li>询问:倒是简单，一个判断，O(1)</li><li>合并：起码O(n)</li></ul></li><li>并查集的好处：用近乎O(1)的时间支持合并和查询两种操作。</li><li>基本原理：用树维护所有集合。<ul><li>每个集合的编号：根节点的编号。</li><li>p[x]：每个点都存储的父节点。</li></ul></li><li>问题1：如何判断树根？ <ul><li>p[x] = x;</li></ul></li><li>问题2：如何求x的集合编号？可以判断两个集合是否同一个。<ul><li>while(p[x]!=x) x=p[x];</li></ul></li><li>问题3：如何合并两个集合？<ul><li>将其中一棵树的父节点插入到第二棵树的父节点下面。</li><li>x，y各自一个集合。p[x] = y;</li></ul></li><li>并查集优化：当一个节点找到根节点，将这个路径上所有的点都执行根节点。<ul><li>近乎O(1)</li></ul></li></ul><h2 id="并查集模板"><a href="#并查集模板" class="headerlink" title="并查集模板"></a>并查集模板</h2><p>核心：find方法，自带优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">并查集--合并集合</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="comment">//返回x所在集合的编号 + 路径压缩优化并查集</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        p[i] = i; <span class="comment">// 初始化的时候每个数都是自己的一个集合</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,&amp;op,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] = <span class="string">&#x27;M&#x27;</span>) p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="经典例题：-连通块内点的个数"><a href="#经典例题：-连通块内点的个数" class="headerlink" title="经典例题： 连通块内点的个数"></a>经典例题： 连通块内点的个数</h2><p><strong>题目描述：</strong><br>给定一个包含 n个点（编号为 1∼n）的无向图，初始时图中没有边。现在要进行 m个操作，操作共有三种：<br>C a b，在点 a和点 b之间连一条边。<br>Q1 a b，询问点 a和点 b是否在同一个连通块中。<br>Q2 a，询问点 a所在连通块中点的数量。</p><p><strong>多加了size数组，表示连通块中点的数量</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">并查集</span></span><br><span class="line"><span class="comment">连通块中点的数量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> p[N],si[N]; <span class="comment">// 新增一个size数组，保存连通块中点的数量,规定只有根节点的size有意义</span></span><br><span class="line"><span class="comment">//返回x所在集合的编号 + 路径压缩优化并查集</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        p[i] = i; <span class="comment">// 初始化的时候每个数都是自己的一个集合</span></span><br><span class="line">        si[i] =<span class="number">1</span>; <span class="comment">//初始化每个集合的大小都是1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] = <span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b) ) <span class="keyword">continue</span>; <span class="comment">//防止size多加</span></span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">            si[<span class="built_in">find</span>(b)]+=si[<span class="built_in">find</span>(a)];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,si[<span class="built_in">find</span>(a)]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-哈希表和字符串哈希</title>
      <link href="/posts/13bb212e.html"/>
      <url>/posts/13bb212e.html</url>
      
        <content type="html"><![CDATA[<h1 id="算法基础：前缀和-差分"><a href="#算法基础：前缀和-差分" class="headerlink" title="算法基础：前缀和+差分"></a>算法基础：前缀和+差分</h1><h2 id="1-前缀和算法"><a href="#1-前缀和算法" class="headerlink" title="1. 前缀和算法"></a>1. 前缀和算法</h2><h3 id="一维前缀和；快速求原数组一段的和"><a href="#一维前缀和；快速求原数组一段的和" class="headerlink" title="一维前缀和；快速求原数组一段的和"></a>一维前缀和；快速求原数组一段的和</h3><p>如何快速初始化前缀和数列？s[i] = s[i-1] + a[i];<br>如何快速求原数组一段的和？对于区间[L,R]:S[r] - S[L-1]; 让S[0]=0<br>代码非常简单：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="comment">//前缀和下标都是从1开始的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="comment">//初始化前缀和数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) s[i] = s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="二维前缀和：快速求小矩形的面积（容斥原理思想）"><a href="#二维前缀和：快速求小矩形的面积（容斥原理思想）" class="headerlink" title="二维前缀和：快速求小矩形的面积（容斥原理思想）"></a>二维前缀和：快速求小矩形的面积（容斥原理思想）</h3><p>如何快速初始化前缀和数列？ s[i,j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1]  + a[i][j];<br>如何快速球以x1y1左上角和x2y2右下角的矩形和： S = S[x2,y2] - S[x2,y1-1] - S[x1-1,y2] + S[x1-1,y1-1]<br>提示：虽然快排在蓝桥杯用不到，但是以后的笔试面试中，面试官可能会让手写快排。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> a[N][N],s[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="type">int</span> a;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">            <span class="comment">//直接边读入边初始化前缀和数组</span></span><br><span class="line">            s[i][j] = s[i<span class="number">-1</span>][j] + s[i][j<span class="number">-1</span>] - s[i<span class="number">-1</span>][j<span class="number">-1</span>] + a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[x2][y2] - s[x2][y1<span class="number">-1</span>] - s[x1][y2<span class="number">-1</span>] + s[x1<span class="number">-1</span>][y1<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-差分算法—前缀和算法的逆运算"><a href="#2-差分算法—前缀和算法的逆运算" class="headerlink" title="2. 差分算法—前缀和算法的逆运算"></a>2. 差分算法—前缀和算法的逆运算</h2><p>作用：对于数组中[l,r]之间的元素，快速让每个元素都加上某个常数c。<br>原理：假想当前数组为前缀和数组，构造出原数组b[n],那么，要让a[l]到a[r]之间的数字都加上c，只需要让b[l]+c;并且让b[r+1]减去c。</p><h3 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>  N = <span class="number">100000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    b[l]+=c;</span><br><span class="line">    b[r+<span class="number">1</span>]-=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="comment">//将初始化当作是在i和i区间插入数字即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">insert</span>(i,i,a[i]);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> l,r,c;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r &gt;&gt; c;</span><br><span class="line">        <span class="built_in">insert</span>(l,r,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) b[i]+=b[i<span class="number">-1</span>];<span class="comment">//递推重新求和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维差分—差分矩阵"><a href="#二维差分—差分矩阵" class="headerlink" title="二维差分—差分矩阵"></a>二维差分—差分矩阵</h3><p>对b[x1][y1]+=c;b[x2+1][y1]-=c;b[x1][y2-1]-=c;b[x2+1][y2+1]+=c<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> a[N][N],b[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="comment">//差分核心</span></span><br><span class="line">    b[x1][y1]+=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y1]-=c;</span><br><span class="line">    b[x1][y2+<span class="number">1</span>]-=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y2+<span class="number">1</span>]+=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">insert</span>(i,j,i,j,a[i][j]);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;c);</span><br><span class="line">        <span class="built_in">insert</span>(x1,y1,x2,y2,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二维前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            b[i][j] = b[i<span class="number">-1</span>][j] + b[i][j<span class="number">-1</span>] - b[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i][j]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-位运算"><a href="#3-位运算" class="headerlink" title="3. 位运算"></a>3. 位运算</h2><h3 id="n的二进制表示中第k位是多少"><a href="#n的二进制表示中第k位是多少" class="headerlink" title="n的二进制表示中第k位是多少"></a>n的二进制表示中第k位是多少</h3><p>步骤：首先把第k位移动到最后一位，其次看最后一位是多少。</p><h3 id="【非常重要】lowbit运算"><a href="#【非常重要】lowbit运算" class="headerlink" title="【非常重要】lowbit运算"></a>【非常重要】lowbit运算</h3><p>功能：返回x的最后一位1开头的二进制数<br>例子：x = 101000  lowbit(x) = 1000<br>实现：x &amp; (-x)<br>作用：求1的个数—每次可以减一个1<br><strong>实例代码：求二进制中1的个数</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x) x-=<span class="built_in">lowbit</span>(x),res++;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-离散化"><a href="#4-离散化" class="headerlink" title="4. 离散化"></a>4. 离散化</h2><p>概念：将值域大个数小的数字映射到从0开始的自然数。<br>问题；</p><ol><li>a[]中有重复元素，必须去重操作。</li><li>如何算出离散化后的值？<br>思路：</li></ol><ul><li>unique函数可以去重并返回尾端点</li><li>可以二分查找某个数<br><strong>示例题目：在一个序列中给某位置上的数加上c后求某个区间和</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据范围：数据下标从-1e9到1e9，加上的数范围是1e5</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;<span class="comment">// 存放左右区间</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>; <span class="comment">// 离散后的数据范围</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],s[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;alls;    <span class="comment">//存放需要离散的数</span></span><br><span class="line">vector&lt;PII&gt;add,query;   <span class="comment">//存放的是需要进行添加和询问操作的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;    <span class="comment">// 二分查找</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid =  l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(alls[mid]&gt;=x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l  = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 注意：排完序下标就是映射的值</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;  <span class="comment">//n个操作，m个询问</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,c;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        add.<span class="built_in">push_back</span>(&#123;x,c&#125;);<span class="comment">//差分操作</span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(x);<span class="comment">//需要映射的数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        query.<span class="built_in">push_back</span>(&#123;l,r&#125;);<span class="comment">//虚伪呢</span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(l);<span class="comment">//需要映射的数字</span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去重操作：先排序后去重。</span></span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>());</span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>()),alls.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//添加操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item : add)&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">find</span>(item.first); <span class="comment">// 查找映射后的下标</span></span><br><span class="line">        a[x] += item.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理前缀和数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">1</span>;i&lt;=alls.<span class="built_in">size</span>();i++) s[i] = s[i<span class="number">-1</span>] + a[i];</span><br><span class="line">    <span class="comment">// 处理询问：一维前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item : query)&#123;</span><br><span class="line">        <span class="type">int</span>  l = <span class="built_in">find</span>(item.first);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">find</span>(item.second);</span><br><span class="line">        cout &lt;&lt; s[r] - s[l<span class="number">-1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-区间合并：贪心算法"><a href="#5-区间合并：贪心算法" class="headerlink" title="5. 区间合并：贪心算法"></a>5. 区间合并：贪心算法</h2>用去区间左端点进行排序。<br>维护的区间分成三种情况：子集、改变end、完全无交集。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;isotream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt;&amp;segs)</span></span>&#123;</span><br><span class="line">    vector&lt;PII&gt;res;</span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(),segs.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed =<span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> seg : segs)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ed &lt; seg.first)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st!=<span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st,ed&#125;);</span><br><span class="line">            st = seg.first;</span><br><span class="line">            ed = seg.sencond;</span><br><span class="line">        &#125;<span class="keyword">else</span> ed = <span class="built_in">max</span>(ed,seg.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(st!=<span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st,ed&#125;);</span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;PII&gt;segs;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> l ,r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        segs.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">merge</span>(segs);</span><br><span class="line">    cout &lt;&lt; segs.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-双指针算法求最长连续不重复子序列"><a href="#6-双指针算法求最长连续不重复子序列" class="headerlink" title="6. 双指针算法求最长连续不重复子序列"></a>6. 双指针算法求最长连续不重复子序列</h2>给定长度为n有序序列，求出最长的不包含重复的数的连续区间长度。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N  = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N],s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        s[a[i]]++;</span><br><span class="line">        <span class="keyword">while</span>(s[a[j]] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            s[a[j]]--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res,i-j+<span class="number">1</span>);<span class="comment">//循环结束i和j之间都没有重复元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt;  res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-链表、栈、队列</title>
      <link href="/posts/16a9b171.html"/>
      <url>/posts/16a9b171.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构—模拟链表、栈、队列"><a href="#数据结构—模拟链表、栈、队列" class="headerlink" title="数据结构—模拟链表、栈、队列"></a>数据结构—模拟链表、栈、队列</h1><h2 id="1-数组模拟单链表"><a href="#1-数组模拟单链表" class="headerlink" title="1. 数组模拟单链表"></a>1. 数组模拟单链表</h2><h3 id="为啥用数组模拟，不用结构体？"><a href="#为啥用数组模拟，不用结构体？" class="headerlink" title="为啥用数组模拟，不用结构体？"></a>为啥用数组模拟，不用结构体？</h3><p>new操作在算法题中速度偏慢，所以笔试用数组模拟链表。</p><h3 id="链表的作用"><a href="#链表的作用" class="headerlink" title="链表的作用"></a>链表的作用</h3><p>单链表在用邻接表存储图和树时十分有用。双链表可用于优化某些问题。</p><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><p>首先来看单链表，单链表属性主要有：<br>head表示头节点，e[N]存储链表的值;ne[N]存储链表下一个节点;idx表示当前的结点（处理第k个插入的数的需求）<br>单链表的操作有：init初始化、头插、插入（插到下标为k的点后）、删除（将下标为k后面的点删除）<br>注意：idx从0开始，所以add要k-1<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> head, e[N],ne[N],idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_head</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//头插入三连</span></span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    head = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = ne[k];</span><br><span class="line">    ne[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> k,x;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;H&#x27;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add_to_head</span>(x);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( op == <span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="comment">//删除需要特判是否为头节点</span></span><br><span class="line">            <span class="keyword">if</span>(!k) head = ne[head];</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">remove</span>(k<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(k<span class="number">-1</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head;i!=<span class="number">-1</span>;i=ne[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-数组模拟双链表"><a href="#2-数组模拟双链表" class="headerlink" title="2. 数组模拟双链表"></a>2. 数组模拟双链表</h2><h3 id="双链表与单链表的区别"><a href="#双链表与单链表的区别" class="headerlink" title="双链表与单链表的区别"></a>双链表与单链表的区别</h3><p>前面单链表用ne[N]记录下一个位置，这里需要l[N]和r[N]记录左右的位置。</p><h3 id="具体操作-1"><a href="#具体操作-1" class="headerlink" title="具体操作"></a>具体操作</h3><p>初始化：0表示左端点，1表示右端点。初始状态下r[0] = 1; l[1] = 0;<br>双链表支持5种操作：<br>最左边插入、最右边插入、将第k个插入的数删除、在第k个插入的数左侧插入，在第k个插入的数右侧插入。<br><strong>在节点a的右边插入一个数</strong>：idx左边指向a，右边指向r[a];通过a访问到r[a]，让r[a]左边指向idx，a的右边指向idx，并自增。<br><strong>删除元素</strong>：l[a]指向r[a],r[a]指向l[a];<br>注意：默认实现右插入，如何实现左插入？add(l[a],x);<br>最后：注意<strong>下标问题</strong>，初始化idx是从2开始的！<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> e[N],l[N],r[N],idx;</span><br><span class="line"><span class="comment">//在节点a的右边插入一个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = a , r[idx] = r[a];</span><br><span class="line">    l[r[a]] = idx, r[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    r[l[a]] = r[a];</span><br><span class="line">    l[r[a]] = l[a];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    r[<span class="number">0</span>]  = <span class="number">1</span>;</span><br><span class="line">    l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//询问</span></span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        string op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="type">int</span> k,x;</span><br><span class="line">        <span class="keyword">if</span>( op == <span class="string">&quot;L&quot;</span> )&#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">insert</span>(<span class="number">0</span>,x); <span class="comment">// 左端插入</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( op == <span class="string">&quot;R&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">insert</span>(l[<span class="number">1</span>],x);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ( op == <span class="string">&quot;D&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="built_in">remove</span>(k+<span class="number">1</span>);<span class="comment">//下标从2开始</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( op == <span class="string">&quot;IL&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">insert</span>(l[k+<span class="number">1</span>],x);<span class="comment">//还是注意下标从2开始</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">insert</span>(k+<span class="number">1</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=r[<span class="number">0</span>];i!=<span class="number">1</span>;i=r[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,e[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-模拟栈"><a href="#3-模拟栈" class="headerlink" title="3. 模拟栈"></a>3. 模拟栈</h2><p>栈：stk[N]  tt：栈顶<br>操作：insert、push、empty、top<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> stk[N],tt;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        string op;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>( op == <span class="string">&quot;push&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt;x;</span><br><span class="line">            stk[++tt] = x;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( op == <span class="string">&quot;pop&quot;</span>) tt--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;empty&quot;</span>) cout &lt;&lt; (tt? <span class="string">&quot;NO&quot;</span> :<span class="string">&quot;YES&quot;</span>) &lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; stk[tt] &lt;&lt;endl; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-模拟队列"><a href="#4-模拟队列" class="headerlink" title="4. 模拟队列"></a>4. 模拟队列</h2><p>队列：q[N]  hh: head  tt: rear<br>初始化: hh = 0   tt = -1<br>操作：insert pop empty getHead<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> q[N],hh,tt=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        string op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="keyword">if</span>( op == <span class="string">&quot;push&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            q[++tt] = x;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( op ==<span class="string">&quot;op&quot;</span>)&#123;</span><br><span class="line">            hh++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( op == <span class="string">&quot;empty&quot;</span>)&#123;</span><br><span class="line">            cout &lt;&lt; (hh&lt;=tt ? <span class="string">&quot;NO&quot;</span> : <span class="string">&quot;YES&quot;</span>) &lt;&lt; endl;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,q[hh]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="提升：单调栈【求离某数最近的且最小元素】"><a href="#提升：单调栈【求离某数最近的且最小元素】" class="headerlink" title="提升：单调栈【求离某数最近的且最小元素】"></a>提升：单调栈【求离某数最近的且最小元素】</h2><h3 id="模型引入"><a href="#模型引入" class="headerlink" title="模型引入"></a>模型引入</h3><p>例题：给一个序列，每一个数左边且离最近的且最小的数字在哪?<br>例如： 3 4 2 7 5  答案就是： -1 3 -1 2 2</p><h3 id="首先考虑暴力解法"><a href="#首先考虑暴力解法" class="headerlink" title="首先考虑暴力解法"></a>首先考虑暴力解法</h3><p>i从0到n  j从n-1到0  找a[j] &lt; a[i] break;</p><h3 id="寻找性质进行优化"><a href="#寻找性质进行优化" class="headerlink" title="寻找性质进行优化"></a>寻找性质进行优化</h3><p><img src="https://s2.loli.net/2023/01/07/6ueqtVrUY7bh3fy.gif" alt="演示单调栈" title="单调栈"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> stk[N],tt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>，&amp;x);</span><br><span class="line">        <span class="keyword">while</span>(tt &amp;&amp; stk[tt]&gt;=x) tt--;</span><br><span class="line">        <span class="keyword">if</span>(!tt) <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,stk[tt]);</span><br><span class="line">        stk[++tt] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="提升：单调队列【滑动窗口】"><a href="#提升：单调队列【滑动窗口】" class="headerlink" title="提升：单调队列【滑动窗口】"></a>提升：单调队列【滑动窗口】</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在一个大小为k的滑动窗口中，求出最大值和最小值</p><h3 id="第一步：考虑普通队列如何做？"><a href="#第一步：考虑普通队列如何做？" class="headerlink" title="第一步：考虑普通队列如何做？"></a>第一步：考虑普通队列如何做？</h3><p>对序列进行扫描，每次完成队列的入队和出队操作，大致需要进行n次。<br>对于每一次，如何求最值？—&gt;序列内部扫描一遍，需要扫描k次。<br>故时间复杂度为O(nk)</p><h3 id="第二步：思考利用性质优化—-gt-优先队列"><a href="#第二步：思考利用性质优化—-gt-优先队列" class="headerlink" title="第二步：思考利用性质优化—&gt;优先队列"></a>第二步：思考利用性质优化—&gt;优先队列</h3><ol><li>将普通队列的冗余元素删掉—&gt;队列具有单调性</li><li>可以用O(1)时间从队列或者队尾求出最值。所以时间优化为O(n)。<h4 id="以最小值为例，k-3为例子："><a href="#以最小值为例，k-3为例子：" class="headerlink" title="以最小值为例，k+3为例子："></a>以最小值为例，k+3为例子：</h4></li><li>如果队伍后面的数字大于新加入的数字new，就没意义。</li><li>把所以增的数字都去掉，</li><li>如果要求最小值，最后队列就是单调递增，只需要取队头即可。<h4 id="演示了一遍就通透很多，直接说有点难说明白"><a href="#演示了一遍就通透很多，直接说有点难说明白" class="headerlink" title="演示了一遍就通透很多，直接说有点难说明白"></a>演示了一遍就通透很多，直接说有点难说明白</h4>直接上代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单调队列--滑动窗口</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> a[N],q[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>,tt = <span class="number">-1</span>;<span class="comment">//模拟队列</span></span><br><span class="line">    <span class="comment">//首先求最小值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//判断是否在窗口内</span></span><br><span class="line">        <span class="keyword">if</span>(hh&lt;=tt &amp;&amp; q[hh] &lt; i-k+<span class="number">1</span>) hh++;</span><br><span class="line">        <span class="comment">//如果最新值小于队尾，不满足单调递增</span></span><br><span class="line">        <span class="keyword">while</span>(hh&lt;=tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--;</span><br><span class="line">        <span class="comment">//入队</span></span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="comment">//最小值：队头元素</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;=k<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//最大值：根据对称性即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//判断是否在窗口内</span></span><br><span class="line">        <span class="keyword">if</span>(hh&lt;=tt &amp;&amp; q[hh] &lt; i-k+<span class="number">1</span>) hh++;</span><br><span class="line">        <span class="comment">//如果最新值小于队尾，不满足单调递增</span></span><br><span class="line">        <span class="keyword">while</span>(hh&lt;=tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--;</span><br><span class="line">        <span class="comment">//入队</span></span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="comment">//最小值：队头元素</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;=k<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础算法-前缀和、差分、位运算、离散化、区间合并</title>
      <link href="/posts/be0049cb.html"/>
      <url>/posts/be0049cb.html</url>
      
        <content type="html"><![CDATA[<h1 id="算法基础：前缀和-差分"><a href="#算法基础：前缀和-差分" class="headerlink" title="算法基础：前缀和+差分"></a>算法基础：前缀和+差分</h1><h2 id="1-前缀和算法"><a href="#1-前缀和算法" class="headerlink" title="1. 前缀和算法"></a>1. 前缀和算法</h2><h3 id="一维前缀和；快速求原数组一段的和"><a href="#一维前缀和；快速求原数组一段的和" class="headerlink" title="一维前缀和；快速求原数组一段的和"></a>一维前缀和；快速求原数组一段的和</h3><p>如何快速初始化前缀和数列？s[i] = s[i-1] + a[i];<br>如何快速求原数组一段的和？对于区间[L,R]:S[r] - S[L-1]; 让S[0]=0<br>代码非常简单：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="comment">//前缀和下标都是从1开始的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="comment">//初始化前缀和数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) s[i] = s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="二维前缀和：快速求小矩形的面积（容斥原理思想）"><a href="#二维前缀和：快速求小矩形的面积（容斥原理思想）" class="headerlink" title="二维前缀和：快速求小矩形的面积（容斥原理思想）"></a>二维前缀和：快速求小矩形的面积（容斥原理思想）</h3><p>如何快速初始化前缀和数列？ s[i,j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1]  + a[i][j];<br>如何快速球以x1y1左上角和x2y2右下角的矩形和： S = S[x2,y2] - S[x2,y1-1] - S[x1-1,y2] + S[x1-1,y1-1]<br>提示：虽然快排在蓝桥杯用不到，但是以后的笔试面试中，面试官可能会让手写快排。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> a[N][N],s[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="type">int</span> a;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">            <span class="comment">//直接边读入边初始化前缀和数组</span></span><br><span class="line">            s[i][j] = s[i<span class="number">-1</span>][j] + s[i][j<span class="number">-1</span>] - s[i<span class="number">-1</span>][j<span class="number">-1</span>] + a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[x2][y2] - s[x2][y1<span class="number">-1</span>] - s[x1][y2<span class="number">-1</span>] + s[x1<span class="number">-1</span>][y1<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-差分算法—前缀和算法的逆运算"><a href="#2-差分算法—前缀和算法的逆运算" class="headerlink" title="2. 差分算法—前缀和算法的逆运算"></a>2. 差分算法—前缀和算法的逆运算</h2><p>作用：对于数组中[l,r]之间的元素，快速让每个元素都加上某个常数c。<br>原理：假想当前数组为前缀和数组，构造出原数组b[n],那么，要让a[l]到a[r]之间的数字都加上c，只需要让b[l]+c;并且让b[r+1]减去c。</p><h3 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>  N = <span class="number">100000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    b[l]+=c;</span><br><span class="line">    b[r+<span class="number">1</span>]-=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="comment">//将初始化当作是在i和i区间插入数字即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">insert</span>(i,i,a[i]);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> l,r,c;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r &gt;&gt; c;</span><br><span class="line">        <span class="built_in">insert</span>(l,r,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) b[i]+=b[i<span class="number">-1</span>];<span class="comment">//递推重新求和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维差分—差分矩阵"><a href="#二维差分—差分矩阵" class="headerlink" title="二维差分—差分矩阵"></a>二维差分—差分矩阵</h3><p>对b[x1][y1]+=c;b[x2+1][y1]-=c;b[x1][y2-1]-=c;b[x2+1][y2+1]+=c<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> a[N][N],b[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="comment">//差分核心</span></span><br><span class="line">    b[x1][y1]+=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y1]-=c;</span><br><span class="line">    b[x1][y2+<span class="number">1</span>]-=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y2+<span class="number">1</span>]+=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">insert</span>(i,j,i,j,a[i][j]);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;c);</span><br><span class="line">        <span class="built_in">insert</span>(x1,y1,x2,y2,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二维前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            b[i][j] = b[i<span class="number">-1</span>][j] + b[i][j<span class="number">-1</span>] - b[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i][j]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-位运算"><a href="#3-位运算" class="headerlink" title="3. 位运算"></a>3. 位运算</h2><h3 id="n的二进制表示中第k位是多少"><a href="#n的二进制表示中第k位是多少" class="headerlink" title="n的二进制表示中第k位是多少"></a>n的二进制表示中第k位是多少</h3><p>步骤：首先把第k位移动到最后一位，其次看最后一位是多少。</p><h3 id="【非常重要】lowbit运算"><a href="#【非常重要】lowbit运算" class="headerlink" title="【非常重要】lowbit运算"></a>【非常重要】lowbit运算</h3><p>功能：返回x的最后一位1开头的二进制数<br>例子：x = 101000  lowbit(x) = 1000<br>实现：x &amp; (-x)<br>作用：求1的个数—每次可以减一个1<br><strong>实例代码：求二进制中1的个数</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x) x-=<span class="built_in">lowbit</span>(x),res++;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-离散化"><a href="#4-离散化" class="headerlink" title="4. 离散化"></a>4. 离散化</h2><p>概念：将值域大个数小的数字映射到从0开始的自然数。<br>问题；</p><ol><li>a[]中有重复元素，必须去重操作。</li><li>如何算出离散化后的值？<br>思路：</li></ol><ul><li>unique函数可以去重并返回尾端点</li><li>可以二分查找某个数<br><strong>示例题目：在一个序列中给某位置上的数加上c后求某个区间和</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据范围：数据下标从-1e9到1e9，加上的数范围是1e5</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;<span class="comment">// 存放左右区间</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>; <span class="comment">// 离散后的数据范围</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],s[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;alls;    <span class="comment">//存放需要离散的数</span></span><br><span class="line">vector&lt;PII&gt;add,query;   <span class="comment">//存放的是需要进行添加和询问操作的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;    <span class="comment">// 二分查找</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid =  l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(alls[mid]&gt;=x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l  = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 注意：排完序下标就是映射的值</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;  <span class="comment">//n个操作，m个询问</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,c;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        add.<span class="built_in">push_back</span>(&#123;x,c&#125;);<span class="comment">//差分操作</span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(x);<span class="comment">//需要映射的数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        query.<span class="built_in">push_back</span>(&#123;l,r&#125;);<span class="comment">//虚伪呢</span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(l);<span class="comment">//需要映射的数字</span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去重操作：先排序后去重。</span></span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>());</span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>()),alls.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//添加操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item : add)&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">find</span>(item.first); <span class="comment">// 查找映射后的下标</span></span><br><span class="line">        a[x] += item.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理前缀和数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">1</span>;i&lt;=alls.<span class="built_in">size</span>();i++) s[i] = s[i<span class="number">-1</span>] + a[i];</span><br><span class="line">    <span class="comment">// 处理询问：一维前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item : query)&#123;</span><br><span class="line">        <span class="type">int</span>  l = <span class="built_in">find</span>(item.first);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">find</span>(item.second);</span><br><span class="line">        cout &lt;&lt; s[r] - s[l<span class="number">-1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-区间合并：贪心算法"><a href="#5-区间合并：贪心算法" class="headerlink" title="5. 区间合并：贪心算法"></a>5. 区间合并：贪心算法</h2>用去区间左端点进行排序。<br>维护的区间分成三种情况：子集、改变end、完全无交集。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;isotream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt;&amp;segs)</span></span>&#123;</span><br><span class="line">    vector&lt;PII&gt;res;</span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(),segs.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed =<span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> seg : segs)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ed &lt; seg.first)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st!=<span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st,ed&#125;);</span><br><span class="line">            st = seg.first;</span><br><span class="line">            ed = seg.sencond;</span><br><span class="line">        &#125;<span class="keyword">else</span> ed = <span class="built_in">max</span>(ed,seg.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(st!=<span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st,ed&#125;);</span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;PII&gt;segs;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> l ,r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        segs.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">merge</span>(segs);</span><br><span class="line">    cout &lt;&lt; segs.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-双指针算法求最长连续不重复子序列"><a href="#6-双指针算法求最长连续不重复子序列" class="headerlink" title="6. 双指针算法求最长连续不重复子序列"></a>6. 双指针算法求最长连续不重复子序列</h2>给定长度为n有序序列，求出最长的不包含重复的数的连续区间长度。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N  = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N],s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        s[a[i]]++;</span><br><span class="line">        <span class="keyword">while</span>(s[a[j]] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            s[a[j]]--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res,i-j+<span class="number">1</span>);<span class="comment">//循环结束i和j之间都没有重复元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt;  res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础算法--高精度运算</title>
      <link href="/posts/ab499439.html"/>
      <url>/posts/ab499439.html</url>
      
        <content type="html"><![CDATA[<h1 id="算法基础：高精度运算"><a href="#算法基础：高精度运算" class="headerlink" title="算法基础：高精度运算"></a>算法基础：高精度运算</h1><p>开头先感慨一下：正如斯坦福CS106L老师讲的，用前沿的C++语言确实比用老套的C美丽得多。<br>在高精度这件事情上，C需要处理的细节十分繁杂，而C++可以让代码更加优美简洁。</p><h2 id="算法—高精度运算"><a href="#算法—高精度运算" class="headerlink" title="算法—高精度运算"></a>算法—高精度运算</h2><p>听说高精度运算这类题目是C++同学独有哈哈，JAVA和python都不需要掌握。（强颜欢笑.jpg）<br>分类</p><ul><li>高精度加法 A + B</li><li>高精度减法 A - B （默认A &gt; B，反之只需特判。如出现负数，分类讨论加减法）</li><li>高精度乘法 A * a （一个大整数除以一个正常数）</li><li>高精度除法 A / a （高精度乘法和除法不会出现大数，概率小）<br><strong>高精度加法</strong><br>加法就是逐位相加，有进位。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">//加法函数</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;A,vector&lt;<span class="type">int</span>&gt;&amp;B)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;C;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>() || i&lt;B.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; A.<span class="built_in">size</span>()) t+=A[i];</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t+=B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t%<span class="number">10</span>);</span><br><span class="line">        t/=<span class="number">10</span>;</span><br><span class="line">        <span class="comment">//一气呵成</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t) C.<span class="built_in">push_back</span>(<span class="number">1</span>);<span class="comment">//最后记得特判是否存在进位</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;A,B;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b; <span class="comment">// a = &quot;123456&quot;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);<span class="comment">//翻转</span></span><br><span class="line">    <span class="comment">//A = [6,5,4,3,2,1]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=b.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">auto</span> C  = <span class="built_in">add</span>(A,B);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>高精度减法</strong><br>主要在于结位。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">//  判断是否有 A&gt;=B</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;A,vector&lt;<span class="type">int</span>&gt;&amp;B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.<span class="built_in">size</span>()!=B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">            <span class="keyword">if</span>(A[i]!=B[i])</span><br><span class="line">                <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 相等也满足条件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;A,vector&lt;<span class="type">int</span>&gt;&amp;B)</span></span>&#123;</span><br><span class="line">    <span class="comment">//进行减法的实现</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;C;</span><br><span class="line">    <span class="comment">//  这里A的位数一定大于等于B的位数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,t=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;B.<span class="built_in">size</span>()) t-=B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t+<span class="number">10</span>)%<span class="number">10</span>); <span class="comment">// 这里可以将两种情况统一来写</span></span><br><span class="line">        <span class="comment">// 这里每一次减法的结果分为：大于等于0 为自己 小于0 借位</span></span><br><span class="line">        <span class="keyword">if</span>(t&lt;<span class="number">0</span>) t =<span class="number">1</span>; <span class="comment">//借位</span></span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//除掉前导0</span></span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>()==<span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;A,B;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b; <span class="comment">// a = &quot;123456&quot;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="comment">//A = [6,5,4,3,2,1]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=b.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(A,B))&#123; <span class="comment">// 是否A&gt;=B</span></span><br><span class="line">        <span class="keyword">auto</span> C = <span class="built_in">sub</span>(A,B);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]); </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> C = <span class="built_in">sub</span>(B,A);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>高精度乘法</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;A,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>() || t;i++)&#123; <span class="comment">//将最后的进位处理合在一起</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;A.<span class="built_in">size</span>()) t += A[i]*b; </span><br><span class="line">        C.<span class="built_in">push_back</span>(t%<span class="number">10</span>);<span class="comment">//当前位数</span></span><br><span class="line">        t/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>); <span class="comment">// 记得转化为整数</span></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">mul</span>(A,b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>高精度除法</strong><br>除法是从最高位开始运算的，本来应该正着存储。<br>但是题目一般不只考察除法，所以倒叙存储。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;A,<span class="type">int</span> b,<span class="type">int</span> &amp;r)</span></span>&#123;</span><br><span class="line">    <span class="comment">//A / b  商C 余r</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 6 5 4 3 2 1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        r = r* <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r/b);</span><br><span class="line">        r%=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1 2 3 4 5 6  但是输出的时候仍旧是反转输出，所以需要reverse</span></span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(),C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//去除前导0</span></span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="type">int</span> r; <span class="comment">// 余数是r</span></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">div</span>(A,b,r);<span class="comment">// A除以b，余数是r，商C</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础算法-快排、归并、二分</title>
      <link href="/posts/c1a0bcc.html"/>
      <url>/posts/c1a0bcc.html</url>
      
        <content type="html"><![CDATA[<h1 id="算法基础：快排、归并排序、二分"><a href="#算法基础：快排、归并排序、二分" class="headerlink" title="算法基础：快排、归并排序、二分"></a>算法基础：快排、归并排序、二分</h1><h2 id="1-快排模板"><a href="#1-快排模板" class="headerlink" title="1. 快排模板"></a>1. 快排模板</h2><p>快排的核心思想:分治。<br>步骤：</p><ol><li>确定分界点。</li><li>重新调整区间。—双指针法。</li><li>递归处理左右两端。<br><strong>快排由于边界问题，建议直接背诵模板</strong><br>提示：虽然快排在蓝桥杯用不到，但是以后的笔试面试中，面试官可能会让手写快排。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;=r ) <span class="keyword">return</span> ; <span class="comment">//边界判断</span></span><br><span class="line">    <span class="comment">//确定分界点</span></span><br><span class="line">    <span class="type">int</span> x = q[l + r &gt;&gt; <span class="number">1</span>], i = l<span class="number">-1</span> , j = r+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//双指针调整区间</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j )&#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) <span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,l,j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,j+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-快速查找算法"><a href="#2-快速查找算法" class="headerlink" title="2. 快速查找算法"></a>2. 快速查找算法</h2>在快速排序基础上返回第k个数。<br>快排分区间的时候，如果k小于左边的长度，递归左边。否则递归右边。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> l , <span class="type">int</span> r, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> q[l]; <span class="comment">//返回查找的值</span></span><br><span class="line">    <span class="type">int</span> x = q[l] , i = l<span class="number">-1</span> , r = r+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j ) <span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//到这里都与快排基本一样</span></span><br><span class="line">    <span class="type">int</span> sl = j - l +<span class="number">1</span>; <span class="comment">//表示左边区间的长度</span></span><br><span class="line">    <span class="keyword">if</span>(k &lt;= sl) <span class="keyword">return</span> <span class="built_in">quick_sort</span>(l,j,k);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">quick_sort</span>(j+<span class="number">1</span>,r,k - sl);<span class="comment">//注意这里是k-sl</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-归并排序"><a href="#3-归并排序" class="headerlink" title="3. 归并排序"></a>3. 归并排序</h2>快排的思路是先调整后递归。<br>归并的思路是先递归排序后合并，合并同样用双指针算法。<br><strong>归并排序时间复杂度严格为NlogN</strong><br><strong>相比之下，快排的时间复杂度期望是NlogN</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l , <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;=r ) <span class="keyword">return</span>;<span class="comment">//递归排序都需要边界</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q,l,mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="comment">//双指针合并</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;=mid &amp;&amp; j&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i] &lt;=q[j]) tmp[k++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k++] = q[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一轮后剩下的push到答案</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) tmp[k++] = q[j++];</span><br><span class="line">    <span class="comment">//重新把tmp数组拷到q数组内</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l,j=<span class="number">0</span>;i&lt;=r;i++,j++)</span><br><span class="line">        q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-整数二分和浮点数二分"><a href="#4-整数二分和浮点数二分" class="headerlink" title="4. 整数二分和浮点数二分"></a>4. 整数二分和浮点数二分</h2>二分的本质：存在某个性质使得左边满足右边不满足。<br>由于整数二分模板有两种类型，具体来实践来看先写check看如何更新，再找答案。<br><strong>浮点数二分：只要区间划分到足够小就好了，注意一下精度的问题，判断条件比题目多两位精度</strong><br>整数二分：以《数的范围》为例。<br>给定一个有序序列，发N个询问，对于每个询问求某数字在序列中起始位置和终止位置。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="comment">//开始二分--找左端点</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[mid] &gt;=x ) r= mid;</span><br><span class="line">            <span class="keyword">else</span> l  = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到左端点先特判是否找到</span></span><br><span class="line">        <span class="keyword">if</span>(a[l] != x) cout &lt;&lt;<span class="string">&quot;-1 -1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; l &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            l = <span class="number">0</span>,r= n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">                <span class="type">int</span> mid = l + r +<span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[mid]&lt;=x) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>浮点数二分<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="type">double</span> l =<span class="number">-10000</span>, r=<span class="number">10000</span>;</span><br><span class="line"><span class="keyword">while</span>(r - l &gt;<span class="number">1e-8</span>)&#123; <span class="comment">// 也可以不管啥直接迭代100次，除以100次。</span></span><br><span class="line">    <span class="type">double</span> mid = (l + r) /<span class="number">2</span>; <span class="comment">// 浮点数不能用位运算</span></span><br><span class="line">    <span class="keyword">if</span>(mid*mid*mid&lt;=x) l = mid;</span><br><span class="line">    <span class="keyword">else</span> r=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.6lf&quot;</span>,l);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stanford CS106L 笔记-lecture01</title>
      <link href="/posts/7ae3cc5d.html"/>
      <url>/posts/7ae3cc5d.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Q : CS106L系列为什么没有继续更新？(2023/02/01)</p><p>A : 之前心血来潮想乘着寒假的机会学习C++17的新特性，所以了解到了CS106L。然而后面学习发现，这个阶段有优先级更高的学习重点需要顾及，如果仍旧学习CS106L，可能导致不仅这门课没学好，其它重点也没顾及到，只能暂时搁置这个项目。</p><p>这门课更多涉及语法的新特性，而自己更想先理解计算机底层相关的东西，暂时没有这个学习计划。</p></blockquote><h1 id="Stream-I"><a href="#Stream-I" class="headerlink" title="Stream I"></a>Stream I</h1><aside>🥊 2022/12/18 14:14</aside><h2 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h2><ul><li>ostringstream</li><li>istringstream</li><li>bit state</li></ul><p>EX：write a function stringToInterger</p><h2 id="stringstream"><a href="#stringstream" class="headerlink" title="stringstream"></a>stringstream</h2><h3 id="ostringstream"><a href="#ostringstream" class="headerlink" title="ostringstream"></a>ostringstream</h3><p>it is not connected to any external source. only type conversion.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span> <span class="comment">// for stringstream</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">ostringstream <span class="title">oss</span><span class="params">(<span class="string">&quot;Ito En Green Tea&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// ostringstream oss(&quot;Ito En Green Tea &quot;,ostringstream::ate);</span></span><br><span class="line">    cout &lt;&lt; oss.<span class="built_in">str</span>() &lt;&lt; endl; </span><br><span class="line">    oss &lt;&lt; <span class="number">16.9</span> &lt;&lt; <span class="string">&quot; Ounce &quot;</span>;</span><br><span class="line">    cout &lt;&lt; oss.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;(Pack of &quot;</span> &lt;&lt; <span class="number">12</span> &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    cout &lt;&lt; oss.<span class="built_in">str</span>() &lt;&lt; endl; <span class="comment">// still overwrite</span></span><br><span class="line"></span><br><span class="line">    <span class="function">istringstream <span class="title">iss</span><span class="params">(oss.str())</span></span>;</span><br><span class="line">    <span class="type">double</span> account;</span><br><span class="line">    string unit;</span><br><span class="line">    iss &gt;&gt; account &gt;&gt; unit;</span><br><span class="line">    cout &lt;&lt; account &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; unit &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;half of the acoount is &quot;</span> &lt;&lt; account/<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/6efd1fdb-47e5-4af2-9bbd-b81223945bd4/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221218%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20221218T085642Z&amp;X-Amz-Expires=86400&amp;X-Amz-Signature=355b26e207a56db547d3d9b0262a67f246d75f4d7cdd1f2a76a60920fc129cb3&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%3D%22Untitled.png%22&amp;x-id=GetObject" alt="Untitled"></p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/6d71654d-ceb6-4a52-8c39-86a62cd97dd7/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221218%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20221218T085711Z&amp;X-Amz-Expires=86400&amp;X-Amz-Signature=b99f3f9e75da238b19d5703849983faf034722976f5dd792dac1390ce33999a8&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%3D%22Untitled.png%22&amp;x-id=GetObject" alt="Untitled"></p><p>The position started in the front, so we are <strong>overwriting</strong> the buffer.</p><p>if you use ostringstream(”something”,ostringstream::ate); then it starts at end.</p><h3 id="istringstream"><a href="#istringstream" class="headerlink" title="istringstream"></a>istringstream</h3><p>input streams read up to the next whitespace</p><p>also skips any leading whitespace</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">ostringstream <span class="title">oss</span><span class="params">(<span class="string">&quot;Ito En Green Tea &quot;</span>)</span></span>;</span><br><span class="line">    oss &lt;&lt; <span class="number">16.9</span>;</span><br><span class="line">    fpos pos = oss.<span class="built_in">tellp</span>() + <span class="built_in">streamoff</span>(<span class="number">3</span>);</span><br><span class="line">    oss.<span class="built_in">seekp</span>(pos);</span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;black&quot;</span> ;</span><br><span class="line">    cout &lt;&lt; oss.<span class="built_in">str</span>() &lt;&lt; endl;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/1c96068f-5463-4a3e-8864-5495d7610567/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221218%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20221218T085724Z&amp;X-Amz-Expires=86400&amp;X-Amz-Signature=63e1d14b766f27ec60a9ff8925917fe4dc07ea462bf20099de6424b3d7654602&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%3D%22Untitled.png%22&amp;x-id=GetObject" alt="Untitled"></p><h3 id="bit-state"><a href="#bit-state" class="headerlink" title="bit state"></a>bit state</h3><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/8551b75d-aa15-46f1-bcb1-bceb9b2007fe/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221218%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20221218T085740Z&amp;X-Amz-Expires=86400&amp;X-Amz-Signature=13d8a299b4c87156acc3a70fa3809621e79f5c75c9cfb0c1d4ea9897b7614133&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%3D%22Untitled.png%22&amp;x-id=GetObject" alt="Untitled"></p><p>good and bad  good and fail are not opposites</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">stringToInteger</span><span class="params">(<span class="type">const</span> string&amp; str)</span></span>&#123;</span><br><span class="line">    <span class="function">istringstream <span class="title">iss</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    iss &gt;&gt;  value;</span><br><span class="line">    <span class="keyword">if</span>(iss.<span class="built_in">fail</span>() || !iss.<span class="built_in">eof</span>()) <span class="keyword">throw</span> <span class="built_in">domain_error</span>(<span class="string">&quot;StringInteger ...&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pritnStateBits</span><span class="params">(istream&amp; s)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;State bits : &quot;</span>;</span><br><span class="line">    cout &lt;&lt; (s.<span class="built_in">good</span>() ? <span class="string">&quot;G&quot;</span> : <span class="string">&quot;-&quot;</span>);</span><br><span class="line">    cout &lt;&lt; (s.<span class="built_in">fail</span>() ? <span class="string">&quot;F&quot;</span> : <span class="string">&quot;-&quot;</span>);</span><br><span class="line">    cout &lt;&lt; (s.<span class="built_in">eof</span>() ? <span class="string">&quot;E&quot;</span> : <span class="string">&quot;-&quot;</span>);</span><br><span class="line">    cout &lt;&lt; (s.<span class="built_in">bad</span>() ? <span class="string">&quot;B&quot;</span> : <span class="string">&quot;-&quot;</span>);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;usage : arg1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> val = <span class="built_in">stringToInteger</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You enter is &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Half of that is &quot;</span> &lt;&lt; val/<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> StanFord </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer第二章兼凌晨发牢骚</title>
      <link href="/posts/873b758e.html"/>
      <url>/posts/873b758e.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="fb597fbb4d5acc6da839cc5a65a5f384aaf686ca2e72cc0ec5d9b92c344ebee2">87e6a8c026cde67c17c2cb1d8c373697e9a4f7931b2158bf244a046f86b0427d64067664aa14508f462562b3c5950a273f33cd30c41e26a8d5bb540d0c582af26006c5c6a5480197b0549637f6396e43f43fc1cf8e3027a559d9cc36ce202a6ae4cfb27a67c43d7d2ffef1d32621784cdbed8548b59da11f8f58a990dc158ae4ae5e033e7422e61ec950893e9b1fdb97d0fe8c905f28d96a24563ce014dd5f4de35eba986ccec32e9e691b5352fe516f69906fad16dbd7382c5393178c6ae0b4e4a36125ea31f4f3fd0c510c44bf783e1684c0ab49fa4c81ebc3d0a7141822547200c1e3714cbe7642b059023ef042ff360e1c214a11d39dd708ace136186e565238a9b50bac596fc5eca32f4504211e8f8cebaec9c2a8585518e4009e27c7522d7d8377561a69c0f56339ce759e7b196079874cf188586c5c4119e13af70a976e96b18a8b2b8599460100b0f23e11bbf33e4c808da5a23001da33f26a8cb1e4c581ff4e726befa92d623dfb4ed87b3466956d79793ebf9a0fae409f3912f3aae2bc4477db1f70181130c6ba8ae3b48ae8f6d88a2431234bc873ec9fe18c6d3e4660b760ff5248513a8857be6c1f0c7f4eae541c6cd4fab3466c9f50d0598dfb20773c22209c0b63f21b8fcb402668a17c40a49c211a24c0373ff65c871b3e5a4cecad6075e9f526c2c540549d9e62ecfd8a3732ff447fdfcccf2c915426e0c8e557698d78a27be37951f354a5b83495ae14e6f83c76b99a9502357514708aa4eac5c87dff6301a9c58122b3f6d9821ede9f4cd5634396e3233adab82bad0ee679d2172f8c37567bea465ef940b29dd375fd877b799269ac93442c7c0dddf1d7705efda02409c45d4e7c5776b14b1d65481e88032fc496f69e9b94f3c82d10df53301267014b32c02dedba958d3af7693983eedfc6e399f6d5468430892bf65e26fcdc5637fdb907e25fb75d962e388016c6d8a5f6ddafefe9134a9e661faad2f547711e64654ad75bb347aee23a2d324143fee228923a9b60e6f5ff60364094d3cca964a6dc2c97cbb7a24e40907bbe6abb5c0c9b2ad834a096f73c2c64dfc780d5f085bc03c433c375586df5f01fbf62d5a4283a163aed7e9e946ad3dc7aa16eddab0084517a6c945790adff246b4a629940351688af34d9accdf3e139f611284867d972a574ad75113e8c903e49c87a847fa35aff14d71baef94e35ad281bec3adca1870a4a71dfe16eafc7e988867668df79c89c70a10e0cb9f9db41dbee9ace36a84810535022f931b7f1a4a7c07b4c0b866aa7dd0cedfdede37be22a8c55f230fb79f18997e1c3bc4293e219be2f8b2df7611ddc51a303c424ddcbc6c751889cf7d68e3eb18c8029567bbff20240dbdc4f04b9ad1a7b5abc5a3a34d3151928568349d506da90c313a803019927cf74edd8179b33ab107604937a73331a6267e8044038476bda71911621044616cc0c2f25a1424ae8e815287bcaf2a1545156ba172d7241dd80c17be2077118147feb1736330e6d9c9475044d0a1dec1a1b61c220a6c470f21db1004276cb970fff8d1e8a4e5a9e45705f7b12f74f8efde3953364b2080b515a271edf551dfecd5f39e1a4b7e36cd34c2bf4f8aa63da15aaeb7f955b841cfe0476f949362f574f2fc9f300bad9086c99482941efc8172fd6a320100ffa86348fdb1c580595b2d615ba1fc29f25a48f7f57136d07dc8be6be7c9d9c1b9427f961819453f1b14211b8d87848ff04112c97b16751f71f759f38ea50f347627548e81af21d719e475bb5aeb5cb63138f2d72b684b4320e39574ff7a57d60ae76576704b3e9b580095f86fddbf91cab1298e1f3624fc4528adfca5da5c70d2ac8e108a431fcd671334679042b325c220713f4bd626378f4e6f988397c75f1e6de7e401a0bbe1c4dfabcc4828a0f81051c3a7443fa8d8d904d4d4fc964d2e179ccef5ae8e4e2fd403056ea34be96a6b51d33a7ee713d8a5057e1f8bdd853d8c82ec476514e94124e0cdeaa0881292f3b52bf2d7ae3d9bea933393d9a524d98e8c86bd74a3b97614932a3962ae2511ca8c7946d46538b15dd1fbdbca294bd114bafdb529a276a89cbe7de747dffe7a39996820b73198a335adbc3cb5afae0265160fa19cecfd97a0b4bfffa46778319793dce7f8d5d090a3b60aea3318a726dfc2d343d1815ec04db048f9d70f483f0681395dfd81cb38d81a08d080acb3416747b2a725ce373fe7951882c67013f184401e5c9d3d9b34e8739ccc33e5002e611a0d99adda06f3ff2d8aa3acfa1251e91528832aa613cafef11a337fbffa552e603af8612e9dc15ef8d2fcc3d84c55b4f8147bb686615afbc3a5a70f8f6e534dee7f987e2627c48c9528c822ef9ed57f0a7768a3340028cb0b11837bea94e7dd2c454e229faab04310ce2546e92ab2ac26e42ffe7298f263e7168f537e9c67995544c566e2d8581dfdc165ca7bd87e6aa6ad1a25fcecf32f676bd1dbcfce1ed480716fe586e4d3b9dd70a486e5396ca922f74cf82fc286913f862d3c60ce5502b92b960817830f605bf4cd1fc5520de532ca1c2fc07333948bcc6619a928659737efc7e1ac69d124e563b5942145c044752f331720377c4b6759d85e624b680a7d12b188a8910c74b5a10eec2fa40fe04f85dab58d8a722222f7997da591c060b498e245591d435f0b8b427385ddee5b75f9d01800eb1567987ab7390748ffd5909ea38b0ae43b4dfc9dbbef83e9c0a9bf54dfcfb0a29d22db20c154a88c2e822948a059fc0c2df21228c0ace0f41067acb4b1d684843a7805008c09a0cc52feff73de8696d1c8bcbbe9df93f92accb976b5afc93091a03d995f6fc367736bb8826361fe38f6b5472246468ac231db829a1d947a191e65cdc9a7a57576202dea42bc897438543504ed7a5340c78f468b7bc95aea17f3009519a0925e3ce8b3c2a6c15b900c693540a30a2557596a6580cb40f0b0d95300fd36e3fb7d81d4a0a37f3d6c18a82065d64a22a5b4ebbf7078c0bfe045b51774b5aa7f67bec130d231e94d4c8edf9c9aee751fe6f5cfe3d920795bf6193a4b67563908a8dd93369fc31ea8ec3c9449147df24f8977c0fae99ac77f457594fb4282560f19e29c0fff4f6fda4a1fe0b4a75377c3d3e7058b80ddd4c4039014d5850bb8d80954e7616925caab64db67739df881f7aefebb85148cf29d519823e88a6375b58975900cd220c0476e9b5e8f6e4d61a9317941e411695868be261021c918997383377a5fd2b65e4867255d49ce32dd037c32a69130ca63155bd5bc62cefa5062016bf663781d9df1373776a87aa99450aad4bdcf597d956f5bafcf80b2911d2167249f5c430313cd797d24312390bce4f3229e5ca55ff050624021a74ca60a1e0ef91db8023ed3c22ace16d8c666f384e3f34bab1956090cadd145056877d2028a79e8a7b76c1c91e2e871d72c73ecc420c29adddd5de79a34497c00cec4ec16753387f90fff0f68f1e6860286eac023b45f68a96959a46bec7e0584aa0bbb24162a0b88afd60023757d9ab7acaf9233733d04c0e440cfad5ce2152de0fb11553500bb1f7f8218e9d39ec0e96034c0a5baafe9ed6c524cee6686e039f35ae7e63c970a8eabe84903c6f4bb8cfeb9a37bcbf0a7fcd3f12d7c9dc27fea29a7c102ed940d21cb0e788c57beeaa8b578aa39f51ffe0473a4edf18b4ea3ce475818616dff7beeeaef2313cc08e9f4aecba305f6b6cce15aaf4519a7ed7f941b0c70ca335a6a9f45f77cb92d363a3a839382faf55ba2db072ed615617c764681cfc77227cf01d55f373d160e95bcfed1c25e7df03b53168f2606cff27621b35ba5a02680362b89f2a8a2af46d2195c0bd3585396601a5b8175821bf8b558a41f3e47f8229c2d454e4b9c7df18049d87231d220c22c5a76103b73925011ff63feda0f1643eb799a1df988a3b7e74e5e9dc1e0a59f3bbc7e61261edf85207318e5ea59fa6b6f22e331312a053803951462a60540ae606b7c957fe6f55ff6b8949c32a991588ea41db104a88876c1fa733ed52892a05b79206bd5a87b5441ecfb01d65567930fc69992801f61e141f761f47560b2cb1de954e6b0d56c80a03a56d6aec4caa29c1048c0198d98aca2292072c87f55bbddfaf0a9153edd9a2f598773da50d943365533dd374900f3725cecde72c3493c4b71cf0db8d84b6e09911f2f13ff24d230288eedfc1682783da27d2d5f943a0fba915259704048a0311271b6cd981832fc2ff3bae1ca578273237737e4e650682e2cd220ffc260d67e8828f51ea6bb1a48d2ba87242723d2e03d0fe168a7eb90feb40773d0daf9380034fbeee7e5c8cb6cb054dae5a2a7a4b425bbdad85b0d1a31fde711f1c334053d617f573cebb784c2f3e3bd34432117cec34674386aeaf2b9c93c9140821540204e31adb19d740812ff2314fab81bf0f4b918df82c0b63de9bc431bb1e1b9349dac302a4c352a9466eb097269fbf79c2d2feda0500840802e56e1ce2261fd2427b28b7186181565ea55389d5bfd672dababc04153cf7a79b8ce4adb7630b864ddc9e8001c1d9ab6a7e4589e5b02f1f64568aacb19b91ae9250d7f6c53916d74245b319979a5b6df2982d109fb1b4bb0c292a1e39759adb79cd2d3ef05e3b022ebe2214991e887714e47b0de283e45842dad8dff5be8a45c3850a7ff3eaf5e97582c3b67b99d91e971e8468c6bf108e4d8b5b84ad8bd0aa5d0d8cab1c2a7918a582c46dcf0701498463ff92cb6661c8a1d3315f526d0ac0251407f059ed18be66424d1a71a7005c080dc1d58ceeb442ebf386c988d8425370cfac28eb17b4b3613bc784ac1b35bd63bade4f75707236b30f940a632477fed5df3dd35d86b99d3939d3276613bdd4216b6756be43f4cadf8a5f8099b19a3ff9863d9bc2b96ecd9469c3e8905225548763ac14abcf46650e5b49cbb4b619171883e50e8f0a5307dcbfde2729a4a9da38b68795380a713550fe605c64c02b7f7f050907fc45ba9c56ed83a5329afdaa6a7ca84d07b88bd914acfb31dd8773c1db23bc1590faf3188fe9d4fad708dd13e2c941e974f11f013ed671ad28447093ac823b9594189131c86948ad796c7ff9080cef3c465e2242205c9426afbfb30c9ff19fa3aea47e4e28a2681bb1ecf7a961c2b35112dc694282dae1effca7f90958db347e72e4df3e4b94105b46e79e973b2c8579b2f6abef278b776edf214ab0f7f20a3814dcefe738e5fb53ef3c6c25808bc6266817892eb5f2b2b88c930add4a530bd074d1b710feaad0df84fc3b7a2684e3638f3ab17dd0529399a734d5573218f5a6fd47d9526c3ded435b17cc083ffd107848a82c468defee64a31f80e59dbcc1ff7041200e77833061e79a5ba3f9d233ea1c3244affc250112a1681f1b0f27e94de91835d12c1ae9ee31eeb4a362dd814458336259154f88326e5c8e1ba3afb3b88d1a5012ecc539e1d009cdc2b3731f20f910e1b3271461e0e7bb6f90cbdfaae9ad10a6af94ee9c99b7b96e46c58e7a35617a039972d8dd60c9484373446b541f97b239ce75ae49ad9716303966b6e88c85d459e5918f4b80004c7402237fa1072e750315b15b9a2200350bc5c0dd3c503ac5aafc3b245af6dea250d5bb8748ab23176c898f084d54611f40feeafa7c1763bce2e4c0d2d73daac5465bb75033c2479d5730e1d71fb872bf27c108ba9df2e286e1b0894aeafb7901882fdc90a42c1eb41734ec4ae0746de5b057478622e37d12849e17eb63318015430f7efa058f110263dcc3bece8fcfd3ccca758344c8c0236c8982a21b30d9a13570688c6e40f20d5288c66212218c204915904e02a12d5182c34e8ff2b10373079c3ecbc93251fc0014094525a87fac4c05cfead3486732044f57e8d4af5e2c2fb9fea0b888430fe00977a0ebe4b495b47c320f033d568977d95bf29f36fdd67bd8279994ca5f1e1f0bef9663ef6ab992ada02d072d451d500576e4d0eeddccc3b09f7fd27535dc7774b0954326ab2a089880933f5c59771a143e84965966810092fa0419a8710654b4b1ba33e17b60b6fc7a1e53b98d56808966110a82bb49a8a9efae04aa6fc42c7be06af1e15ab235582570bac936ae7472dcc1d9c98e2e4a5daab466506f41a92fe75ca2ec9022e0be4f821037cc789ba7a34a33bcb1da005b1f9f06e01fa0f503abc65e267ef0b9e71bedc6b074ac87e8f3f7c4a01a7e01f19a2c2f5a87936d3ea09807c8e068b10b75be546aaa59da644617e65eee2d668c6d99747750750f1a109d9afc5812c8e6ec465733bf26d58d40b98b05433dc6eb8133fd774122979de4b6d33b4d844dc013d3e76528f71019ee460fa321b19ce54fbb3608629ef95a7a325abe4a1f3d9efe6892652d5ac5575051b901c19d21e617af740e243fe06fff72d1f2ceb4debf8cec6fee9f52a43fb2feb894e90ce05bde74a3e74be294405621ab5b60f6e07064b81aa8836c8c3edffaf31a73fc2f5fd4bd903c57f989bd02d79a96ac89968c990a6b823a7f525b55ed98e880ac52061695d0fddb64dc90a8a54b96e2abf1c9a9829558301a0b675ab635c6d874d5a472c56a461c1871fb51769f7a4d471bc85a36ad7f2adf6732b13e9447d311bfde5155991a3ba35d3b1a520e2c03997cf14b976a5eb00d8e3ee116472c5d48bc0771b95ee27a24a37e81f3abb6beab2f73113d578ae55c55fc930d56e444add276f8556b2e2f1bb5e2de470de5992129ff8f5d6ce824881cbbaf68146887fc112f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">抱歉，这篇文章较为私密，暂时不允许偷偷进入哟~</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发测试文章</title>
      <link href="/posts/490cad47.html"/>
      <url>/posts/490cad47.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Web开发测试文章，欢迎互联网的朋友关注小站。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>技术栈点亮</title>
      <link href="/posts/5d6224e5.html"/>
      <url>/posts/5d6224e5.html</url>
      
        <content type="html"><![CDATA[<h1 id="技能树点亮—2023寒春版"><a href="#技能树点亮—2023寒春版" class="headerlink" title="技能树点亮—2023寒春版"></a>技能树点亮—2023寒春版</h1><details class="folding-tag" purple><summary> Java第一阶段 </summary>              <div class='content'>              <p><strong>2022年12月份、2023年的1月份：</strong></p><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>经典数据类型+控制+循环+数组 + 位运算</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>OOP：继承、封装、多态</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>异常处理</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>枚举和注解</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>常见包装类</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>Collection集合</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>泛型</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>Java绘图基础</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>线程</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>IO流</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>MySQL基础</p>            </div><p><strong>预计完成时间：2023年的2月份</strong></p><div class='checkbox cyan'><input type="checkbox" />            <p>阶段项目1—坦克大战游戏</p>            </div><div class='checkbox cyan'><input type="checkbox" />            <p>反射</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>网络编程</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>JDBC和连接池</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>正则表达式</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>阶段项目2—多用户及时通信系统</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>阶段项目3—酒店实时预约系统</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>阶段项目4—图书管理系统</p>            </div>              </div>            </details><details class="folding-tag" red><summary> Java第二阶段 </summary>              <div class='content'>              <p><strong>预计完成时间：2023年的3月份</strong></p><div class='checkbox red'><input type="checkbox" />            <p>JavaScript基础</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>Servlet</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>jsp</p>            </div><p><strong>预计完成时间：2023年的4-6月份</strong></p><div class='checkbox red'><input type="checkbox" />            <p>Ajax</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>Jquery</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>Vue基础</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>SSM框架入门</p>            </div>              </div>            </details><details class="folding-tag" blue><summary> 计算机内功系列 </summary>              <div class='content'>              <p><strong>2022年12月份、2023年的1月份：</strong></p><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>算法基础Level</p>            </div><p><strong>预计完成时间：2023年的2、3月份</strong>：</p><div class='checkbox red'><input type="checkbox" />            <p>数据结构与算法—蓝桥杯备赛Level</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>汇编语言王爽</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>CSAPP初看</p>            </div><p><strong>预计完成时间：2023年的4-6月份</strong></p><div class='checkbox red'><input type="checkbox" />            <p>操作系统导论</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>数据结构与算法—提高Level</p>            </div>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++项目 机房预约系统</title>
      <link href="/posts/4e655e6f.html"/>
      <url>/posts/4e655e6f.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>黑马程序员C++课程的结课小项目，主要用于练习：文件操作、OOP三大特征、多文件编译</p><p>说明：大一上有大概写过这个项目，但是比较囫囵吞枣。这里立一个Flag，下学期C++需要复习的时候将这些小项目重新写一遍，并将思路放到博客上。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法栏目测试文章</title>
      <link href="/posts/9a5f2232.html"/>
      <url>/posts/9a5f2232.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>算法栏目测试文章，感谢互联网的朋友前往小站。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++测试文章</title>
      <link href="/posts/db0108b5.html"/>
      <url>/posts/db0108b5.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是C++ 板块的测试文章，欢迎互联网朋友来到小站。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
